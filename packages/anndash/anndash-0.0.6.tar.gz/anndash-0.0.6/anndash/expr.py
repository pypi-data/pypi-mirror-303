"""plotly express module for `anndash`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09_expr.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/09_expr.ipynb 4
import os, re
from typing import Any, TypedDict

# %% ../nbs/09_expr.ipynb 5
# def base_dropdown(
#     *,
#     xpos: float = 0., 
#     ypos: float = 0., 
#     visible: bool = True, 
#     xanchor: str = 'left', 
#     yanchor: str = 'top', 
#     direction: str = 'down',
#     **kwargs: DropDownKeywords
# ):
#     spec = dict(
#         x=xpos, xanchor=xanchor, y=ypos, yanchor=yanchor,
#         direction=direction, showactive=True, visible=visible
#     )
#     spec.update(**kwargs)
#     return spec




# %% ../nbs/09_expr.ipynb 6
# def base_dropdown(
#     *,
#     xpos: float = 0., ypos: float = 0, visible: bool = True, 
#     xanchor: str = 'left', yanchor: str = 'top', direction: str = 'down',
#     **kwargs
# ):
#     spec = dict(
#         x=xpos, xanchor=xanchor, y=ypos, yanchor=yanchor,
#         direction=direction, showactive=True, visible=visible
#     )
#     spec.update(**kwargs)
#     return spec

# def obs_dropdown(
#     adata: ad.AnnData,
#     keys: set[str] | None = None,
#     label: str | None = None, 
#     **kwargs
# ):
#     label = label or f'obs'
#     keys = keys or adata.obs_keys()
#     spec = base_dropdown(**kwargs)
#     spec.update(buttons = [
#         dict(
#             args=[{
#                 'marker.color': [
#                     obs_color(adata, col)
#                 ],
#             }],
#             method='restyle',
#             label=label,
#         ) for col in keys
#     ])
#     return spec

# def var_dropdown(
#     adata: ad.AnnData,
#     col: str | None = None,
#     layer: str | None = None,
#     label: str | None = None, 
#     **kwargs
# ):
#     label = label or f'var'
#     keys = adata.var[col].values if col else adata.var.index
#     spec = base_dropdown(**kwargs)
#     spec.update(buttons = [
#         dict(
#             args=[{
#                 'marker.color': [
#                     var_color(adata, col, key, layer=layer)
#                 ],
#             }],
#             method='restyle',
#             label=label,
#         ) for key in keys
#     ])
#     return spec


# def axis_dropdown(
#     data: np.ndarray,
#     ax: str = 'x', 
#     ndim: int | None = None,
#     max_dim: int = 10,
#     label: str | None = None, 
#     **kwargs
# ):
#     ndim = min(ndim or data.shape[-1], max_dim)
#     label = label or f'{ax.title()}-axis'
#     spec = base_dropdown(**kwargs)
#     spec.update(buttons = [
#         dict(
#             args=[{ax: [data[:, i]]}],
#             method='restyle',
#             label=label,
#         ) for i in range(ndim)
#     ])
#     return spec

# # def axis_label(
# #     index: int = 0, axis: str | None = None, name: str = 'axis', *, 
# #     x: str | None = None, y: str | None = None, z: str | None = None,
# # ):
# #     axis = axis or ('x' if x else ('y' if y else ('z' if z else 'x')))
# #     return {axis: f'{name}_{index}'}

    
# def axis_label(
#     index: int | None = 0, axis: str | None = None, name: str = 'axis', *, 
#     x: str | None = None, y: str | None = None, z: str | None = None,    
# ) -> dict:
#     if index is None: return dict()    
#     axis = str(axis or x or y or z or 'x')
#     return {f'{axis}': f'{name}_{index}'}

# def basis_labels(
#     basis: str, x: int = 0, y: int = 1, z: int | None = None,
#     key_suffix: str | None = 'axis_title'
# ) -> dict:
#     key_suffix = key_suffix or ''
#     name = basis.removeprefix('X_')
#     spec = axis_label(x, axis='x', name=name) | \
#            axis_label(y, axis='y', name=name) | \
#            axis_label(z, axis='z', name=name)
#     return {f'{k}{key_suffix}': v for k, v in spec.items()}

# def scatter_trace(
#     data: np.ndarray, 
#     x: int = 0, y: int = 1, z: int | None = None,
#     color_vals = None,
#     is_3d: bool | None = None,
# ):
#     maybe_3d = z or data.shape[1] > 2
#     match is_3d:
#         case None:
#             if maybe_3d:
#                 is_3d = True
#         case True:
#             if not maybe_3d:
#                 is_3d = False
#         case False:
#             ...
        
#     opts = dict(mode='markers', marker=dict(color=color_vals))
#     if x is not None: opts.update(x=data[:, x])
#     if y is not None: opts.update(y=data[:, y])
#     if z is not None: opts.update(z=data[:, z])
    
#     # Scatter plot type (2D or 3D)
#     go_plt = go.Scatter3d if is_3d else go.Scatter
#     return go_plt(**opts)
