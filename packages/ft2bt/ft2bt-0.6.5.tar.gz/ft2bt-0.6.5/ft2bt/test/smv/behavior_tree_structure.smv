-------------------------------------------------------------------------------------------------------------------------
-- Behavior Tree Structure for the Formal Verification of Autonomous Vehicles FuSa Supervision Systems
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- Author: Carlos Conejo Barcelo
-- email: carlos.conejo@upc.edu
-- Date: 2024-07-28
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- CONDITION NODE
-------------------------------------------------------------------------------------------------------------------------

-- The output is `true` if the condition is true, `false` otherwise.

MODULE bt_condition(enable_condition, condition)
  VAR
    enable : boolean;
    output : { None, Success, Failure };
  ASSIGN
    init(enable) := FALSE;
    init(output) := None;
    next(enable) := enable_condition;
    next(output) :=
      case
        condition & enable_condition: Success;
        TRUE : Failure;
      esac;
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- ACTION NODE
-------------------------------------------------------------------------------------------------------------------------

-- The output is `running` while the action is being executed, `true` if the action is successful, `false` otherwise.

MODULE bt_action(enable_condition)
  VAR
    enable : boolean;
    goal_reached : boolean;
    output : { None, Running, Failure, Success };
    i : { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
  ASSIGN
    init(enable) := FALSE;
    init(output) := None;
    init(goal_reached) := FALSE;
    init(i) := 0;
    next(enable) := enable_condition | enable;
    next(output) :=
      case
        goal_reached : Success;
        enable_condition | enable: Running;
        TRUE : Failure;
      esac;
    next(i) :=
      case
        output = Running & i<10: i + 1;
        i = 10 : 10;
        TRUE : 0;
      esac;
    next(goal_reached) :=
      case
        goal_reached : goal_reached;
        i < 10: FALSE;
        i >= 10 : TRUE;
        TRUE : goal_reached;
      esac;
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- FALLBACK NODE
-------------------------------------------------------------------------------------------------------------------------

-- The output is `running` if the left child is `running`, `true` if the left child is `true`, right child otherwise.

MODULE bt_fallback(left_bt, right_bt)
  DEFINE 
  output := case
      left_bt.output in { Running, Success } : left_bt.output;
      TRUE : right_bt.output;
    esac;
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- SEQUENCE NODE
-------------------------------------------------------------------------------------------------------------------------

-- The output is `running` if the left child is `running`, `false` if the left child is `false`, right child otherwise.

MODULE bt_sequence(left_bt, right_bt)
  DEFINE
    output :=
      case
        left_bt.output in { Running, Failure } : left_bt.output;
        TRUE : right_bt.output;
      esac;
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- NEGATION NODE
-------------------------------------------------------------------------------------------------------------------------

-- The output is `true` if the child output is `false`, `false` otherwise.

MODULE bt_not(child_bt)
  DEFINE
    output :=
      case
        child_bt.output = Failure : Success;
        child_bt.output = Success : Failure;
        TRUE : child_bt.output;
      esac;
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- PLACEHOLDER NODE
-------------------------------------------------------------------------------------------------------------------------

-- The output is `success` if the condition is true, `failure` otherwise.

MODULE bt_placeholder(condition)
  DEFINE
    output := 
      case
        condition : Success;
        TRUE : Failure;
      esac;
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- BEHAVIOR TREE MODEL DEFINITION (AUTOMATIC GENERATION FROM BEHAVIOR TREE)
-------------------------------------------------------------------------------------------------------------------------

-- Hazard Subtrees (HZ_01 --> e1; HZ_02 --> e2)

MODULE HZ_01(e1)
  VAR
    E1 : bt_condition(TRUE, e1);
    empty : bt_placeholder(FALSE);
    subtree : bt_fallback(E1, empty);
  DEFINE
    output := subtree.output;

MODULE HZ_02(e2)
  VAR
    E2 : bt_condition(TRUE, e2);
    empty : bt_placeholder(FALSE);
    subtree : bt_fallback(E2, empty);
  DEFINE
    output := subtree.output;


-- Operating Situation Subtrees (OS1; OS2)

MODULE OS1(condition, e1, e2)
  VAR
    HZ_01 : HZ_01(e1 & condition);
    SS_01_HZ_01 : bt_action(HZ_01.output = Success);
    HZ_02 : HZ_02(e2 & condition);
    SS_02_HZ_02 : bt_action(HZ_02.output = Success);
    seq_HZ_01 : bt_sequence(HZ_01, SS_01_HZ_01);
    seq_HZ_02 : bt_sequence(HZ_02, SS_02_HZ_02);
    subtree : bt_fallback(seq_HZ_02, seq_HZ_01);
  DEFINE
    output := subtree.output; 

MODULE OS2(condition, e1, e2)
  VAR
    HZ_02 : HZ_02(e2 & condition);
    SS_01_HZ_02 : bt_action(HZ_02.output = Success);
    HZ_01 : HZ_01(e1 & condition);
    SS_01_HZ_01 : bt_action(HZ_01.output = Success);
    seq_HZ_02 : bt_sequence(HZ_02, SS_01_HZ_02);
    seq_HZ_01 : bt_sequence(HZ_01, SS_01_HZ_01);
    subtree : bt_fallback(seq_HZ_02, seq_HZ_01);
  DEFINE
    output := subtree.output; 


-- Item or Root tree (I_01)

MODULE I_01(os, e1, e2)
  VAR
    condition_OS2 : bt_condition(TRUE, os = os2);
    OS2 : OS2(condition_OS2.output = Success, e1, e2);
    condition_OS1 : bt_condition(OS2.output = Failure, os = os1);
    OS1 : OS1(condition_OS1.output = Success, e1, e2);
    seq_OS2 : bt_sequence(condition_OS2, OS2.subtree);
    seq_OS1 : bt_sequence(condition_OS1, OS1.subtree);
    subtree : bt_fallback(seq_OS2, seq_OS1);
  DEFINE
    output := subtree.output;


-- Define the root tree. The frozen variables are the leaves of the tree.

MODULE main
  FROZENVAR
    os : {os1, os2};
    e1: boolean;
    e2: boolean;
  VAR
    I_01 : I_01(os, e1, e2);
-------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------
-- CTL PROPERTIES
-------------------------------------------------------------------------------------------------------------------------

-- PROPOSITION 1
-- Verify that operating situations (os) are being checked until one is successful. 
-- Verify that there is always one successful operating situation.

CTLSPEC
  AG (I_01.condition_OS1.enable & I_01.condition_OS2.enable -> AG(I_01.condition_OS1.output = Success 
  | I_01.condition_OS2.output = Success));


-- PROPOSITION 2
-- Verify that when an operating situation is found, its corresponding hazards are being checked until one is found. 
-- It is not necessary to check all hazards if one is found. If no event is found, any hazard is detected. 

CTLSPEC
  AG (I_01.condition_OS1.output = Success -> AG(I_01.OS1.HZ_01.output = Success | I_01.OS1.HZ_02.output = Success 
  | I_01.OS1.HZ_01.output = Failure & I_01.OS1.HZ_02.output = Failure));

CTLSPEC
  AG (I_01.condition_OS2.output = Success -> AG(I_01.OS2.HZ_01.output = Success | I_01.OS2.HZ_02.output = Success 
  | I_01.OS2.HZ_01.output = Failure & I_01.OS2.HZ_02.output = Failure));


-- PROPOSITION 3
-- Verify that when an event is found, its corresponding safety state action is running until the safety goal is reached

CTLSPEC 
  AG (I_01.OS1.HZ_01.E1.output = Success -> 
  AX( A [I_01.OS1.SS_01_HZ_01.output = Running U I_01.OS1.SS_01_HZ_01.goal_reached]));

CTLSPEC 
  AG (I_01.OS1.HZ_02.E2.output = Success -> 
  AX( A [I_01.OS1.SS_02_HZ_02.output = Running U I_01.OS1.SS_02_HZ_02.goal_reached]));

CTLSPEC 
  AG (I_01.OS2.HZ_01.E1.output = Success -> 
  AX( A [I_01.OS2.SS_01_HZ_01.output = Running U I_01.OS2.SS_01_HZ_01.goal_reached]));

CTLSPEC 
  AG (I_01.OS2.HZ_02.E2.output = Success -> 
  AX( A [I_01.OS2.SS_01_HZ_02.output = Running U I_01.OS2.SS_01_HZ_02.goal_reached]));
-------------------------------------------------------------------------------------------------------------------------

