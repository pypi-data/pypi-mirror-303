import numpy as np
import torch
from _typeshed import Incomplete
from careamics.lightning import VAEModule as VAEModule
from careamics.losses.lvae.losses import get_reconstruction_loss as get_reconstruction_loss, reconstruction_loss_musplit_denoisplit as reconstruction_loss_musplit_denoisplit
from careamics.models.lvae.utils import ModelType as ModelType
from careamics.utils.metrics import RunningPSNR as RunningPSNR, scale_invariant_psnr as scale_invariant_psnr
from torch import nn as nn
from torch.utils.data import Dataset as Dataset
from typing import Literal

class TilingMode:
    TrimBoundary: int
    PadBoundary: int
    ShiftBoundary: int

def clean_ax(ax) -> None: ...
def get_eval_output_dir(saveplotsdir: str, patch_size: int, mmse_count: int = 50) -> str: ...
def get_psnr_str(tar_hsnr, pred, col_idx): ...
def add_psnr_str(ax_, psnr) -> None: ...
def get_last_index(bin_count, quantile): ...
def get_first_index(bin_count, quantile): ...
def show_for_one(idx, val_dset, highsnr_val_dset, model, calibration_stats, mmse_count: int = 5, patch_size: int = 256, num_samples: int = 2, baseline_preds: Incomplete | None = None) -> None: ...
def plot_crops(inp, tar, tar_hsnr, recon_img_list, calibration_stats, num_samples: int = 2, baseline_preds: Incomplete | None = None) -> None: ...
def plot_calibration(ax, calibration_stats) -> None: ...
def shiftedColorMap(cmap, start: int = 0, midpoint: float = 0.5, stop: float = 1.0, name: str = 'shiftedcmap'): ...
def get_fractional_change(target, prediction, max_val: Incomplete | None = None): ...
def get_zero_centered_midval(error): ...
def plot_error(target, prediction, cmap=..., ax: Incomplete | None = None, max_val: Incomplete | None = None) -> None: ...
def get_predictions(idx, val_dset, model, mmse_count: int = 50, patch_size: int = 256): ...
def get_dset_predictions(model: VAEModule, dset: Dataset, batch_size: int, loss_type: Literal['musplit', 'denoisplit', 'denoisplit_musplit'], mmse_count: int = 1, num_workers: int = 4) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, list[float]]: ...

class PatchLocation:
    t: Incomplete
    def __init__(self, h_idx_range, w_idx_range, t_idx) -> None: ...

def get_location_from_idx(dset, dset_input_idx, pred_h, pred_w): ...
def remove_pad(pred, loc, extra_padding, smoothening_pixelcount, frame_shape): ...
def update_loc_for_final_insertion(loc, extra_padding, smoothening_pixelcount): ...
def stitch_predictions(predictions, dset, smoothening_pixelcount: int = 0): ...
def stitch_predictions_new(predictions, dset): ...

class Calibration:
    def __init__(self, num_bins: int = 15, mode: Literal['pixelwise', 'patchwise'] = 'pixelwise') -> None: ...
    def logvar_to_std(self, logvar: np.ndarray) -> np.ndarray: ...
    def compute_bin_boundaries(self, predict_logvar: np.ndarray) -> np.ndarray: ...
    def compute_stats(self, pred: np.ndarray, pred_logvar: np.ndarray, target: np.ndarray) -> dict[int, dict[str, np.ndarray | list]]: ...

def nll(x, mean, logvar): ...
def get_calibrated_factor_for_stdev(pred: np.ndarray | torch.Tensor, pred_logvar: np.ndarray | torch.Tensor, target: np.ndarray | torch.Tensor, batch_size: int = 32, epochs: int = 500, lr: float = 0.01): ...
