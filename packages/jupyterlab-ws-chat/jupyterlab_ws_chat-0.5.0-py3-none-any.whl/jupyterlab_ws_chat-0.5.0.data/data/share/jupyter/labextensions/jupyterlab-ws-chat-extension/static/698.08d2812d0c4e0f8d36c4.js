"use strict";(self.webpackChunkjupyterlab_ws_chat_extension=self.webpackChunkjupyterlab_ws_chat_extension||[]).push([[698],{2698:(e,t,n)=>{n.r(t),n.d(t,{default:()=>p});var s=n(656),o=n(7909),i=n(2200),r=n(9480),a=n(5215),c=n(4614),l=n(1473),d=n(7354),h=n(7262);class u extends s.ChatModel{constructor(e={}){var t;super(e),this._userId="",this._socket=null,this._sendResolverQueue=new Map,this._connectionInitialized=new h.PromiseDelegate,this.serverSettings=null!==(t=e.serverSettings)&&void 0!==t?t:d.ServerConnection.makeSettings(),this.name="chat"}get userId(){return this._userId}set userId(e){this._userId=e}async initialize(){this._initialize(),await this._connectionInitialized.promise}sendMessage(e){return e.id=h.UUID.uuid4(),new Promise((t=>{var n;null===(n=this._socket)||void 0===n||n.send(JSON.stringify(e)),this._sendResolverQueue.set(e.id,t)}))}async getHistory(){let e={messages:[]};try{e=await async function(e="",t={}){const n=d.ServerConnection.makeSettings(),s=l.URLExt.join(n.baseUrl,"api/chat",e);let o;try{o=await d.ServerConnection.makeRequest(s,t,n)}catch(e){throw new d.ServerConnection.NetworkError(e)}let i=await o.text();if(i.length>0)try{i=JSON.parse(i)}catch(e){console.log("Not a JSON response body.",o)}if(!o.ok)throw new d.ServerConnection.ResponseError(o,i.message||i);return i}("history",{method:"GET"})}catch(e){return Promise.reject(e)}return e}dispose(){super.dispose();const e=this._socket;e&&(this._socket=null,e.onopen=()=>{},e.onerror=()=>{},e.onmessage=()=>{},e.onclose=()=>{},e.close())}messageAdded(e){var t;"msg"===e.type?(e.sender.id===this.userId&&(null===(t=this._sendResolverQueue.get(e.id))||void 0===t||t(!0)),super.messageAdded(e)):"connection"===e.type&&(this.userId=e.client_id,this._connectionInitialized.resolve(!0))}_onClose(e){if(this._connectionInitialized.reject(new Error("Chat UI websocket disconnected")),console.error("Chat UI websocket disconnected"),1006===e.code){const e=1;console.info(`Will try to reconnect in ${e} s.`),setTimeout((async()=>await this.initialize()),1e3*e)}}_initialize(){if(this.isDisposed)return;console.log("Creating a new websocket connection for chat...");const{token:e,WebSocket:t,wsUrl:n}=this.serverSettings,s=l.URLExt.join(n,"api/chat")+(e?`?token=${encodeURIComponent(e)}`:""),o=this._socket=new t(s);o.onclose=e=>this._onClose(e),o.onerror=e=>console.error(e),o.onmessage=e=>e.data&&this.messageAdded(JSON.parse(e.data))}}const g="jupyterlab-ws-chat-extension:chat",p=[{id:"jupyterlab-ws-chat-extension:autocompletionRegistry",description:"An autocompletion registry",autoStart:!0,provides:s.IAutocompletionRegistry,activate:e=>new s.AutocompletionRegistry},{id:g,description:"A chat extension for Jupyterlab",autoStart:!0,requires:[a.IRenderMimeRegistry],optional:[s.IAutocompletionRegistry,o.ILayoutRestorer,r.INotebookTracker,c.ISettingRegistry,i.IThemeManager],activate:async(e,t,n,o,i,r,a)=>{const{commands:c}=e,l=new s.ActiveCellManager({tracker:i,shell:e.shell}),d=new s.SelectionWatcher({shell:e.shell}),h=new u({commands:e.commands,activeCellManager:l,selectionWatcher:d});let p=!1,m=!0,w=!0,y=!0;function k(e){p=e.get("sendWithShiftEnter").composite,m=e.get("stackMessages").composite,w=e.get("unreadNotifications").composite,y=e.get("enableCodeToolbar").composite,h.config={sendWithShiftEnter:p,stackMessages:m,unreadNotifications:w,enableCodeToolbar:y}}Promise.all([e.restored,null==r?void 0:r.load(g)]).then((([,e])=>{e?(k(e),e.changed.connect(k)):console.warn("The SettingsRegistry is not loaded for the chat extension")})).catch((e=>{console.error(`Something went wrong when reading the settings.\n${e}`)}));let v=null;try{await h.initialize(),v=(0,s.buildChatSidebar)({model:h,themeManager:a,rmRegistry:t,autocompletionRegistry:n})}catch(e){v=(0,s.buildErrorWidget)(a)}e.shell.add(v,"left",{rank:2e3}),o&&o.add(v,"jupyter-chat"),c.addCommand("websocket-chat:focusInput",{caption:"Focus the input of the chat widget",isEnabled:()=>null!==v,execute:async()=>{null!==v&&(e.shell.activateById(v.id),h.focusInput())}})}}]}}]);