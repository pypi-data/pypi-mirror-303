import hashlib
import math
import operator

words = [
    "animated",
    "facetious",
    "stippled",
    "peppy",
    "joking",
    "riotous",
    "spotted",
    "multicolored",
    "vivid",
    "opalescent",
    "vigorous",
    "malleable",
    "translucent",
    "gamesome",
    "showy",
    "tittering",
    "variegated",
    "far-out",
    "agile",
    "glittery",
    "giggling",
    "hooting",
    "blissful",
    "bubbly",
    "checkered",
    "comical",
    "speckled",
    "groovy",
    "splattered",
    "gossamer",
    "foamy",
    "carbonated",
    "jocular",
    "dazzling",
    "ornate",
    "hilarious",
    "freckled",
    "deep",
    "harlequin",
    "loony",
    "velvety",
    "fluffy",
    "lighthearted",
    "laughter",
    "lively",
    "silky",
    "glowing",
    "outlandish",
    "laughing",
    "fizzy",
    "wacky",
    "frisky",
    "ecstatic",
    "bizarre",
    "effervescent",
    "rollicking",
    "humorous",
    "intense",
    "cheerful",
    "elated",
    "ludicrous",
    "kaleidoscopic",
    "absurd",
    "jovial",
    "witty",
    "slapstick",
    "lustrous",
    "zany",
    "ridiculous",
    "luminous",
    "spellbinding",
    "patchwork",
    "convivial",
    "flashy",
    "dynamic",
    "frothy",
    "piebald",
    "mottled",
    "captivating",
    "snappy",
    "effulgent",
    "spirited",
    "bedazzling",
    "shiny",
    "colorful",
    "exuberant",
    "cackling",
    "entertaining",
    "diaphanous",
    "teasing",
    "farcical",
    "spangled",
    "sudsy",
    "prankish",
    "light",
    "decorated",
    "vivacious",
    "happy",
    "speedy",
    "goofy",
    "good-natured",
    "furry",
    "pied",
    "crystalline",
    "sportive",
    "ostentatious",
    "gut-busting",
    "snickering",
    "bejeweled",
    "eye-catching",
    "chortling",
    "cordial",
    "jocose",
    "brilliant",
    "extravagant",
    "prismatic",
    "breezy",
    "chuckling",
    "iridescent",
    "limpid",
    "perky",
    "ebullient",
    "jolly",
    "affable",
    "incandescent",
    "bantering",
    "waggish",
    "mirthful",
    "smiley",
    "bellowing",
    "joyful",
    "sunny",
    "giggly",
    "brisk",
    "pliable",
    "quick",
    "glossy",
    "striking",
    "mesmerizing",
    "billowy",
    "roaring",
    "blithe",
    "zesty",
    "sprightly",
    "beaming",
    "mischievous",
    "sidesplitting",
    "mind-bending",
    "enchanting",
    "whimsical",
    "kidding",
    "bright",
    "upbeat",
    "sparkling",
    "sleek",
    "droll",
    "quirky",
    "uproarious",
    "flecked",
    "shimmery",
    "pearlescent",
    "coltish",
    "amusing",
    "plaid",
    "transparent",
    "vibrant",
    "plush",
    "energetic",
    "supple",
    "gaudy",
    "wispy",
    "mind-boggling",
    "shining",
    "frolicsome",
    "lithe",
    "smooth",
    "coruscating",
    "mind-expanding",
    "giddy",
    "kooky",
    "rubbery",
    "snorting",
    "nimble",
    "airy",
    "knee-slapping",
    "chipper",
    "embellished",
    "adorned",
    "soft",
    "clear",
    "polished",
    "downy",
    "jesting",
    "trippy",
    "bewitching",
    "bouncy",
    "good-humored",
    "playful",
    "bold",
    "hysterical",
    "gleaming",
    "eccentric",
    "grinning",
    "jubilant",
    "carefree",
    "motley",
    "ethereal",
    "rainbow-hued",
    "amiable",
    "psychedelic",
    "resplendent",
    "spattered",
    "scintillating",
    "jaunty",
    "dotted",
    "zippy",
    "peculiar",
    "merry",
    "howling",
    "buoyant",
    "flexible",
    "sparkly",
    "dappled",
    "cushy",
    "polychromatic",
    "twinkling",
    "gleeful",
    "roguish",
    "saturated",
    "squishy",
    "elastic",
    "genial",
    "springy",
    "flamboyant",
    "puckish",
    "impish",
    "elaborate",
    "swift",
    "delightful",
    "funny",
    "silly",
    "nutty",
    "pellucid",
    "hypnotic",
    "odd",
    "mind-blowing",
    "cheery",
    "glittering",
    "diverting",
    "rich",
    "limber",
    "radiant",
    "feathery",
    "fuzzy",
    "festooned",
    "rib-tickling",
]

animals = [
    "quetzal",
    "koala",
    "spider",
    "mongoose",
    "fish",
    "mouse",
    "rat",
    "chinchilla",
    "zebra",
    "mule",
    "camel",
    "owl",
    "cormorant",
    "lobster",
    "echidna",
    "mandrill",
    "alpaca",
    "curlew",
    "mink",
    "gorilla",
    "panther",
    "cat",
    "goose",
    "aardwolf",
    "beaver",
    "duck",
    "lark",
    "caterpillar",
    "mallard",
    "trout",
    "vulture",
    "tapir",
    "goshawk",
    "salamander",
    "hippocampus",
    "chicken",
    "flamingo",
    "quail",
    "pheasant",
    "hyena",
    "vicuÃ±a",
    "monkey",
    "toad",
    "kudu",
    "finch",
    "ostrich",
    "partridge",
    "skunk",
    "guanaco",
    "gull",
    "hedgehog",
    "kingfisher",
    "sparrow",
    "bat",
    "rhinoceros",
    "red-eyed tree frog",
    "crocodile",
    "bee",
    "porcupine",
    "frog",
    "weasel",
    "aardvark",
    "ferret",
    "lemur",
    "elk",
    "kiwi",
    "dhole",
    "gibbon",
    "falcon",
    "ibex",
    "shrew",
    "hornet",
    "dolphin",
    "quokka",
    "chamois",
    "dugong",
    "fossa",
    "porpoise",
    "bouncing",
    "raccoon",
    "caribou",
    "sheep",
    "lyrebird",
    "kouprey",
    "goldfish",
    "zebu",
    "gnu",
    "grasshopper",
    "hummingbird",
    "dove",
    "dog",
    "cheetah",
    "spoonbill",
    "seal",
    "albatross",
    "oyster",
    "capybara",
    "deer",
    "pigeon",
    "macaroni penguin",
    "chimpanzee",
    "opossum",
    "elephant",
    "swallow",
    "bear",
    "snail",
    "wren",
    "iguana",
    "crow",
    "hare",
    "mosquito",
    "rabbit",
    "rook",
    "dingo",
    "locust",
    "parrot",
    "sand dollar",
    "yapok",
    "boar",
    "reindeer",
    "woodcock",
    "alligator",
    "jaguar",
    "cattle",
    "jellyfish",
    "emu",
    "hawk",
    "yak",
    "dinosaur",
    "turkey",
    "dotterel",
    "herring",
    "stork",
    "ape",
    "mole",
    "magpie",
    "rail",
    "numbat",
    "chough",
    "sandpiper",
    "lapwing",
    "cod",
    "platypus",
    "cobra",
    "newt",
    "tiger",
    "horse",
    "jackal",
    "jay",
    "loris",
    "kangaroo",
    "cassowary",
    "ibis",
    "ram",
    "stingray",
    "antelope",
    "wolf",
    "woodpecker",
    "clam",
    "hamster",
    "manatee",
    "red deer",
    "seahorse",
    "wolverine",
    "wasp",
    "jerboa",
    "serval",
    "coati",
    "whistling duck",
    "moose",
    "ermine",
    "human",
    "wallaby",
    "xenops",
    "crab",
    "pony",
    "whale",
    "marten",
    "stinkbug",
    "grouse",
    "narwhal",
    "nightingale",
    "bison",
    "goldfinch",
    "giraffe",
    "salmon",
    "turtle",
    "uakari",
    "red panda",
    "ocelot",
    "louse",
    "worm",
    "walrus",
    "gerbil",
    "octopus",
    "termite",
    "tardigrade",
    "snake",
    "tarsier",
    "lion",
    "dunlin",
    "pig",
    "quelea",
    "oryx",
    "swan",
    "chameleon",
    "viper",
    "butterfly",
    "kookabura",
    "badger",
    "eel",
    "meerkat",
    "dogfish",
    "baboon",
    "scorpion",
    "penguin",
    "wombat",
    "crane",
    "llama",
    "sardine",
    "shark",
    "squirrel",
    "ant",
    "wildcat",
    "raven",
    "binturong",
    "squid",
    "anteater",
    "otter",
    "dragonfly",
    "armadillo",
    "coyote",
    "leopard",
    "buffalo",
    "pelican",
    "fennec fox",
    "okapi",
    "gazelle",
    "eland",
    "fox",
    "cockroach",
    "heron",
    "barracuda",
    "goat",
    "beluga",
    "eagle",
    "axolotl",
    "donkey",
    "lemming",
    "peafowl",
    "starling",
    "hippopotamus",
    "sloth",
    "fly",
    "gnat",
    "gaur",
]


class Hasher:
    def __init__(self):
        self.wordlist = (words, animals)

    def humanize_list(self, hexdigest, n=2):
        """
        Human a given hexadecimal digest, returning a list of words.

        Change the number of words output by specifying `words`.

            >>> digest = '60ad8d0d871b6095808297'
            >>> HumanHasher().humanize_list(digest)
            ['equal', 'monkey', 'lake', 'beryllium']
        """
        if n == 3:
            self.wordlist = (words, words, animals)
        # Gets a list of byte values between 0-255.
        bytes_ = map(
            lambda x: int(x, 16), map("".join, zip(hexdigest[::2], hexdigest[1::2]))
        )
        # Compress an arbitrary number of bytes to n words.
        compressed = self.compress(bytes_, n)

        return [str(self.wordlist[i][byte]) for i, byte in enumerate(compressed)]

    @staticmethod
    def compress(bytes_, target):
        """
        Compress a list of byte values to a fixed target length.

            >>> bytes_ = [96, 173, 141, 13, 135, 27, 96, 149, 128, 130, 151]
            >>> list(HumanHasher.compress(bytes_, 4))
            [64, 145, 117, 21]

        If there are less than the target number bytes, return input bytes

            >>> list(HumanHasher.compress(bytes_, 15))  # doctest: +ELLIPSIS
            [96, 173, 141, 13, 135, 27, 96, 149, 128, 130, 151]
        """

        bytes_list = list(bytes_)

        length = len(bytes_list)
        # If there are less than the target number bytes, return input bytes
        if target >= length:
            return bytes_

        # Split `bytes` evenly into `target` segments
        # Each segment hashes `seg_size` bytes, rounded down for some
        seg_size = float(length) / float(target)
        # Initialize `target` number of segments
        segments = [0] * target
        seg_num = 0

        # Use a simple XOR checksum-like function for compression
        for i, byte in enumerate(bytes_list):
            # Divide the byte index by the segment size to assign its segment
            # Floor to create a valid segment index
            # Min to ensure the index is within `target`
            seg_num = min(int(math.floor(i / seg_size)), target - 1)
            # Apply XOR to the existing segment and the byte
            segments[seg_num] = operator.xor(segments[seg_num], byte)

        return segments

    def humanize(self, text: str, n=2, separator="-"):
        """
        Humanize a given hexadecimal digest.

        Change the number of words output by specifying `words`. Change the
        word separator with `separator`.

            >>> digest = '60ad8d0d871b6095808297'
            >>> HumanHasher().humanize(digest)
            'equal-monkey-lake-beryllium'
            >>> HumanHasher().humanize(digest, words=6)
            'sodium-magnesium-nineteen-william-alanine-nebraska'
            >>> HumanHasher().humanize(digest, separator='*')
            'equal*monkey*lake*beryllium'
        """

        sha1_hash = hashlib.sha1(text.encode("utf-8")).hexdigest()
        # Map the compressed byte values through the word list.
        return separator.join(self.humanize_list(sha1_hash, n))


HASHER = Hasher()
humanize = HASHER.humanize

if __name__ == "__main__":
    hasher = Hasher()
    text = "yellow submarines"
    human = hasher.humanize(text, n=2)
    print(human)
