# Copyright (c) 2024 Justin Davis (davisjustin302@gmail.com)
#
# MIT License
# ruff: noqa: S404, S603
from __future__ import annotations

import logging
from dataclasses import dataclass
from pathlib import Path
from statistics import mean, median
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable

_log = logging.getLogger(__name__)


@dataclass
class Metric:
    raw: list[float | int]
    mean: float | int | None = None
    median: float | int | None = None
    min: float | int | None = None
    max: float | int | None = None

    def __post_init__(self) -> None:
        if not self.raw:
            err_msg = "Raw data cannot be empty"
            raise ValueError(err_msg)

        self.min = min(self.raw)
        self.median = median(self.raw)
        self.max = max(self.raw)
        self.mean = mean(self.raw)


def parse_tegrastats(file: Path | str) -> list[dict[str, str]]:
    """
    Parse a file written by Tegrastats or tegrastats.

    This a general purpose parser which does not seperate entries
    or handle types. All values are still strings in original format.

    The differences from raw entry/values are:
    1. values such as (cached 0MB) become entires: CACHED: 0MB. However
    these pieces of data are part of a two-piece entry for the memory
    subsystems, so representation in fixed format (dict[str, str])
    required a change.
    2. temperature entries such as cpu@49.01C become: CPU_TEMP: 49.01C
    This change upholds that all data generated from tegrastats has
    uppercase keys and that cpu frequencies will not clash with cpu
    temperature.

    Whether or not the file was written by the class Tegrastats
    or directly by tegrastats will be determined automatically.
    Output generated by Tegrastats (Python class) will have
    a timestamp field. The Python timestamp is present as 'timestamp'.

    Example entry (from Orin AGX 64GB):
    {
    'timestamp': '1729630462.0975535',  # optional entry
    'DATE': '10-22-2024',
    'TIME': '15:54:22',
    'RAM': '23336/62841MB',
    'LFB': '199x4MB',
    'SWAP': '0/31421MB',
    'CACHED': '0MB',
    'CPU': '[0%@2201,50%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201,0%@2201]',
    'GR3D_FREQ': '0%',
    'CPU_TEMP': '48.812C',
    'TBOARD_TEMP': '38.5C',
    'SOC2_TEMP': '44.843C',
    'TDIODE_TEMP': '38.875C',
    'SOC0_TEMP': '46.156C',
    'GPU_TEMP': '43.687C',
    'TJ_TEMP': '48.812C',
    'SOC1_TEMP': '45.656C',
    'VDD_GPU_SOC': '5191mW/5190mW',
    'VDD_CPU_CV': '1996mW/2032mW',
    'VIN_SYS_5V0': '4528mW/4539mW',
    'VDDQ_VDD2_1V8AO': '401mW/411mW'
    }

    Parameters
    ----------
    file : Path, str
        The path to the file.

    Returns
    -------
    list[dict[str, str]]
        The parsed data, each entry in the list is one line from tegrastats

    Raises
    ------
    FileNotFoundError
        If the file does not exist

    """
    file = Path(file)
    if not file.exists():
        err_msg = f"Could not find tegrastats output: {file}"
        raise FileNotFoundError(err_msg)

    with file.open("r") as f:
        lines = f.readlines()

    _log.debug(f"Parsing tegrastats output with: {len(lines)} entries")

    py_delim = "::"
    python = False
    if py_delim in lines[0]:
        python = True

    entries: list[dict[str, str]] = []
    for raw in lines:
        # make entry
        entry: dict[str, str] = {}

        # strip newline
        line = raw.strip()

        # parse out python timestamp if exists
        timestamp = None
        if python:
            timestamp, line = line.split(py_delim)
        if timestamp:
            entry["timestamp"] = timestamp

        # parse remainder of line
        data = line.split(" ")

        # first two entires are always date and time (minute resolution)
        entry["DATE"] = data[0]
        entry["TIME"] = data[1]
        data = data[2:]

        # from now on each entry is UPPERCASE value
        # additional values will start with (
        # if value is found that starts with (
        # then it will be treaded as UPPERCASE value
        # by removing the ()
        name = None
        paran = False
        for value in data:
            if name is None:
                # handle paran data
                if value[0] == "(":
                    new_value = value[1:].upper()
                    paran = True
                    name = new_value
                # handle temp data
                elif "@" in value:
                    soc, temp = value.split("@")
                    temp_name = f"{soc.upper()}_TEMP"
                    entry[temp_name] = temp
                else:
                    name = value
            else:
                if paran:
                    new_value = value[:-1]
                    paran = False
                    entry[name] = new_value
                    name = None
                else:
                    entry[name] = value
                    name = None

        # write back the entry
        entries.append(entry)

    return entries


def get_data(
    data: list[dict[str, str]],
    names: list[str],
    parsefunc: Callable[[str], float | int],
) -> dict[str, Metric]:
    """
    Parse the output from parse_tegrastats to specific output.

    Parameters
    ----------
    data : list[dict[str, str]]
        The output of parse_tegrastats
    names : list[str]
        The entries of data to get
    parsefunc: Callable[[str], T]
        The parsing function to apply to each entries values

    Returns
    -------
    dict[str, list[T]]
        The parsed values, each value is the parsed values

    """
    raw: dict[str, list[float | int]] = {}

    for name in names:
        raw[name] = []

    for entry in data:
        for name in names:
            str_value = entry[name]
            value = parsefunc(str_value)
            raw[name].append(value)

    metrics: dict[str, Metric] = {}
    for name in names:
        raw_data = raw[name]
        metrics[name] = Metric(raw=raw_data)

    return metrics


def get_energy(
    data: list[dict[str, str]],
) -> dict[str, Metric]:
    """
    Parse the output from parse_tegrastats to give energy values.

    Parameters
    ----------
    data : list[dict[str, str]]
        The output of parse_tegrastats

    Returns
    -------
    dict[str, list[float]]
        The parsed values, each value is the parsed values

    """

    def parse_energy_value(value: str) -> float:
        return float(value.split("/")[0][:-2])

    names = [name for name in data[0] if "VDD" in name or "VIN" in name]
    return get_data(data, names, parse_energy_value)
