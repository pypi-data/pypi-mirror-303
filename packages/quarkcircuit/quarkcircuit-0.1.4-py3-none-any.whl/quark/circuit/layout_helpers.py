# Copyright (c) 2024 XX Xiao

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files(the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import networkx as nx
import numpy as np
from typing import Literal
from itertools import combinations,zip_longest
from .backend import Backend

def find_neighbours_n_times(G: nx.Graph, node: int, n: int) -> list:
    """Recursively find the neighbors of a given node and extend the neighbor search n times.

    Args:
        G (nx.Graph): An undirected graph.
        node (int): The starting node for the search.
        n (int): The depth of recursion, representing the number of times to find neighbors. If n is 0, an empty list is returned.

    Returns:
        list: A list of all unique neighbors found during the n recursive steps.
    """
    if n == 0:
        return []
    else:
        current_neighbours = list(G.neighbors(node))
        neighbours = current_neighbours.copy()
        for neighbour in current_neighbours:
            neighbours += find_neighbours_n_times(G, neighbour, n - 1)
        return list(set(neighbours))

def get_layout(nqubits:int, chip_info: dict, use_priority:bool, 
               key: Literal['fidelity_var','fidelity_mean'] = 'fidelity_var', 
               topology: Literal['linear1','linear2','cycle','nonlinear'] = 'linear1', 
               printdetails: bool = False, drawgraph: bool = False) -> tuple[list,list]:
    """
    Generate a layout for the specified number of qubits based on the given quantum chip information, and return the layout along with the edges of the subgraph.

    Args:
        nqubits (int): The number of qubits needed in the layout.
        chip_info (dict):  A dictionary containing information about the quantum chip, generated by chip configuration.
        use_priority (bool): If True, select the layout based on the chip's priority qubits list.
                             If False, select the layout using the specified performance metric and topology.
        key (str, optional): The performance metric used for selecting the layout, defaults to 'fidelity_var'.
        topology (str, optional): The topology to use for qubit selection, defaults to 'linear1'. 
        printdetails (bool, optional): If True, print detailed information about the layout selection process. Defaults to False.
        drawgraph (bool, optional): If True, draw the selected layout graph. Defaults to False.

    Raises:
        ValueError: ValueError: If `use_priority` is True and no priority qubit layout with the specified number of qubits is found.

    Returns:
        tuple[list, list]: A tuple containing:
            - list: The selected qubit layout.
            - list: The edges in the subgraph corresponding to the selected layout.
    """
    backend = Backend(chip_info)
    if use_priority:
        priority_qubits_list = backend.priority_qubits
        for qubits in priority_qubits_list:
            if len(qubits) == nqubits:
                print('The layout selected based on chip priority qubits:', qubits)
                layout = qubits
                break
        else:
            raise ValueError(f"No priority qubits with {nqubits} qubits found, please set use_priority as 'False' to search.")
    else:
        layout = Layout(nqubits, backend).select_layout(key,topology,printdetails=printdetails)
        print('The layout selected based on {} condition and {} topology: {}'.format(key,topology,layout))
        
    subgraph = backend.graph.subgraph(layout)
    edges = list(subgraph.edges)
    if drawgraph:
        backend.picknodes = layout
        backend.draw()
    return list(layout), edges
        
class Layout:
    """
    Responsible for selecting suitable qubit layouts from a given chip for a quantum circuit.

    This class generates qubit layouts based on the required number of qubits, performance metrics, 
    and the topology of the chip. It is designed to help map and execute quantum circuits on 
    specific quantum hardware.
    """
    def __init__(self,nqubits: int, chip_backend: Backend):
        """Initialize the Layout class with the required number of qubits and chip backend.

        Args:
            nqubits (int): The number of qubits needed in the layout.
            chip_backend (Backend): An instance of the Backend class that contains the information 
            about the quantum chip to be used for layout selection
        """
        self.nqubits = nqubits
        self.graph = chip_backend.graph
        self.size = chip_backend.size

    def get_all_subgraph(self) -> list:
        """
        Retrieve all unique subgraphs of the chip graph with exactly `nqubits` nodes.
        
        This function generates all possible subgraphs of the chip's connectivity graph 
        that consist of `nqubits` nodes, ensuring no duplicates.

        Returns:
            list: A list of subgraph's nodes.
        """
        components = list(nx.connected_components(self.graph))
        print('number of G components:',len(components))
        collect = []
        remove_lst = []
        for component in components:
            cc = []
            for node0 in component:
                cc = find_neighbours_n_times(self.graph,node0,self.nqubits-1)
                remove_lst.append(node0)
                for rr in remove_lst:
                    if rr in cc:
                        cc.remove(rr)
                if len(cc) >= (self.nqubits-1):
                    for ss in combinations(cc,self.nqubits-1):
                        tt = [node0,] + list(ss)
                        sg = self.graph.subgraph(tt)
                        if nx.is_connected(sg):
                            collect.append(tuple(tt))
                cc = []
        print('number of subgraphs:',len(collect))
        return collect
    
    def classify_subgraph(self) -> tuple[list,list,list,list]:
        """
        Classify the collected subgraphs based on their topological structure into four categories.

        This function sorts the subgraphs into the following four categories:
        1. Linear and connected, with all nodes in the same row of the chip.
        2. Linear and connected, with nodes not in the same row.
        3. Contains a cycle within the subgraph.
        4. Non-linear and connected, where some nodes have more than three edges.
    
        Returns:
            tuple[list, list, list, list]: A tuple containing four lists, each corresponding 
            to one of the four categories of subgraphs.
        """
        cycle_subgraph_list  = []
        linear1_subgraph_list  = []
        linear2_subgraph_list = []
        nonlinear_subgraph_list = []
        all_subgraph = self.get_all_subgraph()
        for nodes in all_subgraph:
            subgraph = self.graph.subgraph(nodes)
            subgraph_degree = dict(subgraph.degree())
            subgraph_fidelity = np.array([data['weight'] for u, v, data in subgraph.edges(data=True)])
            fidelity_mean = np.mean(subgraph_fidelity)
            fidelity_var  = np.var(subgraph_fidelity)
            nodes_info = (nodes, fidelity_mean, fidelity_var)
            if max(subgraph_degree.values()) <= 2:
                if min(subgraph_degree.values()) == 2:
                    cycle_subgraph_list.append(nodes_info)
                else:
                    in_a_line = []
                    for node1, node2 in combinations(nodes,2):
                        if abs(node1-node2) <= (self.size[1]-1):
                            in_a_line.append(True)
                        else:
                            in_a_line.append(False)
                    if len(set(in_a_line)) == 1:
                        linear1_subgraph_list.append(nodes_info)
                    else:
                        linear2_subgraph_list.append(nodes_info)
            else:
                nonlinear_subgraph_list.append(nodes_info)
        return linear1_subgraph_list,linear2_subgraph_list,cycle_subgraph_list,nonlinear_subgraph_list
    
    def sort_subgraph_according_mean_fidelity(self, printdetails: bool = True):
        """Sort each of the four subgraph categories based on the main of fidelity on the edges (couplers), 
        in ascending order.

        Args:
            printdetails (bool, optional): If True, print details of the sorting process. Defaults to True.

        Returns:
            tuple[list, list, list, list]: Four sorted lists, each corresponding to one of the four 
            subgraph categories, with subgraphs sorted by edge fidelity variance.
        """
        linear1_subgraph_list, linear2_subgraph_list, cycle_subgraph_list, nonlinear_subgraph_list = self.classify_subgraph()
        linear1_subgraph_list_sort = sorted(linear1_subgraph_list,key=lambda x: x[1],reverse=True)
        linear2_subgraph_list_sort = sorted(linear2_subgraph_list,key=lambda x: x[1],reverse=True)
        cycle_subgraph_list_sort = sorted(cycle_subgraph_list,key=lambda x: x[1],reverse=True)
        nonlinear_subgraph_list_sort = sorted(nonlinear_subgraph_list,key=lambda x: x[1],reverse=True)
        if printdetails:
            print(len(linear1_subgraph_list_sort),len(linear2_subgraph_list_sort),len(cycle_subgraph_list_sort),len(nonlinear_subgraph_list_sort))
            print('The average fidelity is arranged in descending order,only print the first ten.')
            length = self.nqubits*5+22

            print('{:<3} | {:^{}} | {:^{}} | {:^{}} | {:^{}} |'.format(\
                'idx','subgraph with linear1 topology',length,'subgraph with linear2 topology',length,'subgraph with cycle topology',length,'subgraph with nonlinear topology',length))
            for i, (linear1,linear2,cycle,nonlinear) in enumerate(zip_longest(linear1_subgraph_list_sort,\
                                                                              linear2_subgraph_list_sort,\
                                                                              cycle_subgraph_list_sort,\
                                                                              nonlinear_subgraph_list_sort, fillvalue=' ')):
                if i >= len(linear1_subgraph_list_sort):
                    linear1 = ('(                  )',0.0,0.0)
                if i >= len(linear2_subgraph_list_sort):
                    linear2 = ('(                  )',0.0,0.0)
                if i >= len(cycle_subgraph_list_sort):
                    cycle = ('(                  )',0.0,0.0)
                if i >= len(nonlinear_subgraph_list_sort):
                    nonlinear = ('(                  )',0.0,0.0)
                if i <= 10:
                    print('{:<3} | {:<{}} {:<10.6f} {:<10.6f} | {:<{}} {:<10.6f} {:<10.6f} | {:<{}} {:<10.6f} {:<10.6f} | {:<{}} {:<10.6f} {:<10.6f}'\
                          .format(i, \
                                  str(linear1[0]),self.nqubits*5,linear1[1],linear1[2],\
                                  str(linear2[0]),self.nqubits*5,linear2[1],linear2[2],\
                                  str(cycle[0]),self.nqubits*5,cycle[1],cycle[2],\
                                  str(nonlinear[0]),self.nqubits*5,nonlinear[1],nonlinear[2])\
                                  )
                    
        return linear1_subgraph_list_sort[:5],linear2_subgraph_list_sort[:5],cycle_subgraph_list_sort[:5],nonlinear_subgraph_list_sort[:5]
    
    def sort_subgraph_according_var_fidelity(self,printdetails: bool = True):
        """
        Sort each of the four subgraph categories based on the variance of fidelity on the edges (couplers), 
        in ascending order.
    
        This function sorts the subgraphs within each category (from the previous classification) by the 
        variance of fidelity across the edges in each subgraph, from lowest to highest.
    
        Args:
            printdetails (bool, optional): If True, print details of the sorting process. Defaults to True.
    
        Returns:
            tuple[list, list, list, list]: Four sorted lists, each corresponding to one of the four 
            subgraph categories, with subgraphs sorted by edge fidelity variance.
        """
        linear1_subgraph_list, linear2_subgraph_list, cycle_subgraph_list, nonlinear_subgraph_list = self.classify_subgraph()
        linear1_subgraph_list_sort = sorted(linear1_subgraph_list,key=lambda x: x[2])
        linear2_subgraph_list_sort = sorted(linear2_subgraph_list,key=lambda x: x[2])
        cycle_subgraph_list_sort = sorted(cycle_subgraph_list,key=lambda x: x[2])
        nonlinear_subgraph_list_sort = sorted(nonlinear_subgraph_list,key=lambda x: x[2])
        
        if printdetails:
            print(len(linear1_subgraph_list_sort),len(linear2_subgraph_list_sort),len(cycle_subgraph_list_sort),len(nonlinear_subgraph_list_sort))
            print('The average fidelity is arranged in descending order, only print the first ten.')
            length = self.nqubits*5+22

            print('{:<3} | {:^{}} | {:^{}} | {:^{}} | {:^{}} |'.format(\
                'idx','subgraph with linear1 topology',length,'subgraph with linear2 topology',length,'subgraph with cycle topology',length,'subgraph with nonlinear topology',length))
            for i, (linear1,linear2,cycle,nonlinear) in enumerate(zip_longest(linear1_subgraph_list_sort,\
                                                                              linear2_subgraph_list_sort,\
                                                                              cycle_subgraph_list_sort,\
                                                                              nonlinear_subgraph_list_sort, fillvalue=' ')):
                if i >= len(linear1_subgraph_list_sort):
                    linear1 = ('(                  )',0.0,0.0)
                if i >= len(linear2_subgraph_list_sort):
                    linear2 = ('(                  )',0.0,0.0)
                if i >= len(cycle_subgraph_list_sort):
                    cycle = ('(                  )',0.0,0.0)
                if i >= len(nonlinear_subgraph_list_sort):
                    nonlinear = ('(                  )',0.0,0.0)
                
                if i <= 10:
                    print('{:<3} | {:<{}} {:<10.6f} {:<10.6f} | {:<{}} {:<10.6f} {:<10.6f} | {:<{}} {:<10.6f} {:<10.6f} | {:<{}} {:<10.6f} {:<10.6f}'\
                          .format(i, \
                                  str(linear1[0]),self.nqubits*5,linear1[1],linear1[2],\
                                  str(linear2[0]),self.nqubits*5,linear2[1],linear2[2],\
                                  str(cycle[0]),self.nqubits*5,cycle[1],cycle[2],\
                                  str(nonlinear[0]),self.nqubits*5,nonlinear[1],nonlinear[2])\
                                  )

        return linear1_subgraph_list_sort[:5],linear2_subgraph_list_sort[:5],cycle_subgraph_list_sort[:5],nonlinear_subgraph_list_sort[:5]

    def select_layout(self,
                      key: Literal['fidelity_mean', 'fidelity_var'] = 'fidelity_var',
                      topology: Literal['cycle', 'linear1', 'linear', 'nonlinear'] = 'linear1',
                      printdetails: bool = False):
        """
        Select a qubit layout based on the given performance metric and topology.
    
        This function chooses a layout for the quantum circuit from the available subgraphs based on 
        the specified key (performance metric) and topology type.
    
        Args:
            key (Literal['fidelity_mean', 'fidelity_var'], optional): The performance metric to use for 
                selecting the layout. Either the mean fidelity ('fidelity_mean') or fidelity variance 
                ('fidelity_var'). Defaults to 'fidelity_var'.
            topology (Literal['cycle', 'linear1', 'linear', 'nonlinear'], optional): The desired topology 
                of the layout. It can be 'cycle', 'linear1' (connected, in the same row), 'linear' (connected, 
                not necessarily in the same row), or 'nonlinear'. Defaults to 'linear1'.
            printdetails (bool, optional): If True, prints details about the selected layout. Defaults to False.
    
        Returns:
            list: A list of qubits representing the selected layout.
        """
        if key == 'fidelity_mean':
            linear1_list,linear2_list,cycle_list,nonlinear_list = self.sort_subgraph_according_mean_fidelity(printdetails=printdetails)
        elif key == 'fidelity_var':
            linear1_list,linear2_list,cycle_list,nonlinear_list = self.sort_subgraph_according_var_fidelity(printdetails=printdetails)
        
        if topology == 'cycle':
            subgraph_nodes = cycle_list[0][0]
        elif topology == 'linear1':
            subgraph_nodes = linear1_list[0][0]
        elif topology == 'linear2':
            subgraph_nodes = linear2_list[0][0]
        elif topology == 'nonlinear':
            subgraph_nodes = nonlinear_list[0][0]

        return subgraph_nodes