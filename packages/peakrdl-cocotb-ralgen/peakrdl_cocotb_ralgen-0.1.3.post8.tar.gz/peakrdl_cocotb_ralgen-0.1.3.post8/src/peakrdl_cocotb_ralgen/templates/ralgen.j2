class {{node.get_path_segment()}}_RAL_Test:
    masks={{preg}}
    def __init__(self,regmodel,bg_wrFn=None,bg_rdFn=None):
        self.regmodel=regmodel
        self.get_signal_value=bg_rdFn
        self.set_signal_value=bg_wrFn
        logger.info(f'''
        Cocotb RALGEN: SystemRDL to RALtest converter.
        Copyright Â© 2024 Dyumnin Semiconductors.
        https://dyumnin.com
        ''')
        pass
    def reset_test(self,verbose=False):
        error_count=0
        for key,val in self.masks.items():
            if 'reset' in val['disable']:
                continue
            rv=0
            for hsh in val['signals']:
               rv|=self.get_signal_value(hsh)<< hsh['low']
            try:
                assert rv & val['reset_mask'] == val['reset_value'], "%s Resetvalue mismatch Actual %X,Expected %X," %(key,rv & val['reset_mask'], val['reset_value'])
            except:
              cocotb.log.error("Error Reset Read Reg:%s, Value %s"%(key,rv))
              error_count+=1
            if verbose:
                logger.info("Reset Read Reg:%s, Value %s"%(key,rv))
        assert error_count ==0, f"Test exited with {error_count} Error"

    async def rw_test(self,foreground_write=True,foreground_read=True,count=10,default_value=None,verbose=False):
        # TODO Handle background oprations
        # assert foreground_write and foreground_read, "Error Background operations are not yet defined"
        for key,val in self.masks.items():
            if 'rw' in val['disable']:
                continue
            r=self.regmodel.__getattribute__(key)
            rv=None
            donttest=val['donttest']
            for _ in range(count):
                if default_value:
                    wrval=default_value
                else:
                    wrval=random.randint(0,2**val['regwidth'])
                wval=wrval & ~val['donttest']
                if foreground_write:
                    await r.write(wval)
                else:
                    for hsh in val['signals']:
                        self.set_signal_value(hsh,wval)
                if foreground_read:
                    rv=await r.read()
                else:
                    rv=0
                    for hsh in val['signals']:
                       rv|=self.get_signal_value(hsh)<< hsh['low']
                wmask=val['write_mask']
                rmask=val['read_mask']
                actual=rv&wmask&~donttest
                expected= wval& wmask &rmask
                assert actual==expected,"%s:: Read Write Written %x, Read %x, Expected %x, wrMask %x rdmask %x, donttest = %x"%(key,wrval,actual,expected,wmask,rmask, donttest)
            if verbose:
                logger.info(f"Test RW: {key} wval {wval:x} rv {rv:x} expected {expected:x} actual {actual:x}")
