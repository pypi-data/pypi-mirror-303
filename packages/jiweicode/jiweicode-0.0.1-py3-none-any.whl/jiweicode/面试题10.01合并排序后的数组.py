'''
      题目：给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

      初始化 A 和 B 的元素数量分别为 m 和 n。


                输入:
                A = [1,2,3,0,0,0], m = 3
                B = [2,5,6],       n = 3

                输出: [1,2,2,3,5,6]

      分析：  A中 为0的 是预留的位置。

'''

#  方法一.最为直接的方法（使用排序的方法）。   直接使用 python原生 的方法 进行排序sort,最简单的方式
def fun1(A, m, B, n):
    A[m:] = B
    A.sort()
    return A

#  方法二.  不适用排序的方式，只用双指针的方法
'''
简单的双指针问题，i指向A待排序的末尾，j指向B中待排序的末尾。注意处理特殊情况即可。
因为至多只扫描m+n个元素，所以时间复杂度为O(m+n)。只储存ii和jj两个指针，
所以空间复杂度O(1)。

'''
def fun2(A,m,B,n):
    # 三个 重要的索引指针位置的创建，    首先记录待排序的末尾          以及等待插入的起点位置
    i=m-1
    j=n-1
    index=m+n-1

    # 持续性的 后插入, 直到B 都插入都 A中。   也就是B中待排序的空了
    while j >=0:
        #如果A排序完成的时候，那么直接把B附加过去即可。  因为A先排完，那么A其实就被放在后面了，所以前面的直接放过去就好
        if i<0:
            A[0:j+1]=B[0:j+1]
            break
        # 另一种根据大小位置挪动的情况，这里是A放后面  （因为是有小到大的排序， 所以这里从后面的位置获取i进行比较，大的放最后即可）
        elif A[i]>B[j]:
            A[index]=A[i]
            i-=1
        # 当B中大时，把B放在后面
        else:
            A[index]=B[j]
            j-=1

        #最后的  插入的索引上的更新
        index-=1

    return A


