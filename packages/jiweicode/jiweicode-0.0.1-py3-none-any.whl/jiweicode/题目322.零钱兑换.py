# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
      如果没有任何一种硬币组合能组成总金额，返回 -1。

      示例 1:
        输入: coins = [1, 2, 5], amount = 11
        输出: 3
        解释: 11 = 5 + 5 + 1

      分析：

      思路：动态规划。用dp[i] 表示组成 i 元所需要的最小硬币数。
        显然对于coins数组里的所有元素j，所有的dp[j] = 1。
        以样例输入一为例：对于其他的dp[i] = 1 + min(dp[i - 1], dp[i - 2], dp[i - 5])
        即求11元的答案可以转化为： 1个一元硬币 + 10元答案 或者 1个两元硬币 + 9元答案 或者1个五元硬币 + 6元答案。
        所以dp[i] = 1 + min(dp[i - j]) for j in coins。

'''
class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        if amount == 0:
            return 0
        dp = list()
        max_int = 2 << 31

        for i in range(amount + 1):
            if i not in coins:
                dp.append(max_int)
            else:
                dp.append(1)

        for i in range(amount + 1):
            if i not in coins:
                for j in coins:
                    if i - j > 0:
                        dp[i] = min(dp[i - j] + 1, dp[i])
        return dp[amount] if dp[amount] != max_int else -1

#___________________________________    练习1   ______________________________#
#  这题，从题意就较为简单，让计算  组成一个金额  所需要的coins硬币的最小数量，感觉也可以使用动态规划的方法计算
'''
     我润色了本文，并添加了更多干货内容，希望本文成为解决动态规划的一部「指导方针」。再说句题外话，我们的公众号开号至今写了起码十几篇文章拆解动态规划问题，我都整理到了公众号菜单的「文章目录」中，它们都提到了动态规划的解题框架思维，本文就系统总结一下。这段时间本人也从非科班小白成长到刷通半个 LeetCode，所以我总结的套路可能不适合各路大神，但是应该适合大众，毕竟我自己也是一路摸爬滚打过来的。

   算法技巧就那几个套路，如果你心里有数，就会轻松很多，本文就来扒一扒动态规划的裤子，形成一套解决这类问题的思维框架。废话不多说了，上干货。
动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。
既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。
动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！
首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。
另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。
以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。
下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。


   感觉这篇文章就是动态规划指南：   https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/
                        找时间专门琢磨琢磨看看
                        
                        

    当前：
        用dp[i] 来表示组成i块钱，需要最少的硬币数，那么
        第j个硬币我可以选择不拿 这个时候， 硬币数 = dp[i]
        第j个硬币我可以选择拿 这个时候， 硬币数 = dp[i - coins[j]] + 1
        和背包问题不同， 硬币是可以拿任意个
        对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i]
    
    时间复杂度：O(amonut * len(coins))
    空间复杂度：O(amount)


'''
def fun1(coins,amount):
    # 边界金额值
    if amount==0:
        return 0

    #初始状态和  极值设定。    这里的状态值表示 计算得到每个金额（1到amount）所需要的最少硬币数量
    dp=list()
    max_int=2<<31

    #第一波，进行  最小累计，只是一个简单的累加而已
    for i in range(amount+1):
        #这里  在最大金额范围内，可以直接用的就为1
        if i in coins:
            dp.append(1)
        else:
            dp.append(max_int)

    #第二波，开始动真功夫，进行 状态转移上的设定  (动态规划主要的过程，两个for和两个if的逻辑含义要把握好)
    for i  in range(amount+1):
        if i not in coins:
            #对于可以使用硬币，一个个来尝试  附加在i上
            for j in coins:
                # 这里i-j 可能是能靠 硬币组合的，或者必能被硬币组合的，如果不能，则保持原样即可
                if i-j>0:
                    # 进行很常用的状态转移
                    dp[i]=min(dp[i-j]+1,dp[i])

    #最后  设定的要找到的状态如下，是我们需要得到的amount对应的最小值
    return dp[amount] if dp[amount]!=max_int else -1






