# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。
            输入: "(()"
            输出: 2
            解释: 最长有效括号子串为 "()"

            输入: ")()())"
            输出: 4
            解释: 最长有效括号子串为"()()"

      分析：

      思路：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/
         其实这里主要有三种方式吧，分别是  暴力法、动态规划、栈的方式。

         主要是使用栈的方式。
         【3】与找到每个可能的子字符串后再判断它的有效性不同，我们可以用栈在遍历给定字符串的过程中去判断到目前为止扫描的子字符串的有效性，
         同时能得到最长有效字符串的长度。我们首先将 −1 放入栈顶。

            对于遇到的每个 \text{‘(’}‘(’ ，我们将它的下标放入栈中。
            对于遇到的每个 \text{‘)’}‘)’ ，我们弹出栈顶的元素并将当前元素的下标与弹出元素下标作差，得出当前有效括号字符串的长度。通过这种方法，
         我们继续计算有效子字符串的长度，并最终返回最长有效子字符串的长度。

         时间复杂度： O(n) 。 n 是给定字符串的长度。
         空间复杂度： O(n) 。栈的大小最大达到 nn 。

'''
class Solution(object):
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        #注意栈中，我们每次存放的是索引，之后  也是根据索引来获取 长度。   这里的栈记住只存储（左括号
        stack = [-1]
        res = 0
        for i, x in enumerate(s):

            #这里如果是 （  就可以一直往栈里面放，这个无所谓。
            if x == "(":
                stack.append(i)
            else:
                #如果是）括号的话，首先 我们是跟栈做匹配弹出的。
                stack.pop()

                #这里比较核心的是，i - stack[-1]中，stack[-1] 表示上一个（,也就是能匹配的左括号的位置，知道位置就能计算差距了。
                if stack:
                    #重要的，进行最长长度上的判别。 这里是个标识位吧，就是因为（）（）如果直接全匹配了，就没有标识了，如果是(()()我们就可以利用第一个（标识有效的长度了，soga.
                    res = max(res, i - stack[-1])
                else:
                    #如果栈为空，这样压进去），又有什么意义呢？ 明白了，是个标识位。因为全匹配形式会匹配成空的。
                    stack.append(i)

        return res
#___________________________________    练习1   ______________________________#
# 对于 s下最长 有效括号长度的 求出
def fun1(s):
    stack=[-1]
    res=0
    #这里是以栈的方式  由前往后
    for i,x in enumerate(s):
        #两种括号形式的区分对待
        if x=='(':
            stack.append(i)
        else:
            stack.pop()
            # 如果stack不为空，就 计算最大的括号匹配值, 由符号位置标号所确定的匹配字串长度...
            if stack:
                res=max(res,i-stack[-1])
            else:
                stack.append(i)
    return res


