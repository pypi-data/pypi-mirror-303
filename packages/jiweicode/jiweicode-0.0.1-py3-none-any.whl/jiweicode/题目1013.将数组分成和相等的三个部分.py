'''

   题目：
        给你一个整数数组?A，只有可以将其划分为三个和相等的非空部分时才返回?true，否则返回 false。
        形式上，如果可以找出索引?i+1 < j且满足?(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])?就可以将数组三等分。

        示例 1：

            输出：[0,2,1,-6,6,-7,9,1,2,0,1]
            输出：true
            解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
        示例 2：

            输入：[0,2,1,-6,6,7,9,-1,2,0,1]
            输出：false
        示例 3：

            输入：[3,3,6,5,-2,2,5,1,-9,4]
            输出：true
            解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4



    思路： 这个题中可以发现一个特性，就是能够通过划分三块的方式，是连续位置，而不是可以抽取随机位置，所以思路就简单的多，做三次和为 sum(A)/3的块累加判别即可，非常简单。

        我们要将数组平均分成三分，那么每一份的和一定是sum(A)/3。因此我们的思路就是：

            从左往右遍历，遍历的同时累加，当加到 sum(A)/3，我们cnt + 1。累加器归零
            最后我们只要检查 cnt 大于等于 3， 且累加器归零就好了。

        时间复杂度：O(N)   空间复杂度：O(1)

'''
class Solution:
    def canThreePartsEqualSum(self,A):
        # 我们要将数组平均分成三分，那么每一份的和一定是sum(A)/3
        total = sum(A)

        # 边界条件
        if total % 3 != 0:
            return False

        # 其中 cnt是满足和为total % 3的子数组个数累计。      cur 是对暂时统计中，子数组累计和的统计，会在每次收集后清0。
        cur = cnt = 0

        #从左往右遍历  （探索是够可以划分成等和的三部分。）
        for a in A:
            cur += a

            # 遍历的同时累加，当加到 sum(A)/3，我们cnt + 1
            if cur == total // 3:
                cnt += 1
                cur = 0

        #最后我们只要检查 cnt 大于等于 3， 且累加器归零就好
        return cnt >= 3 and cur == 0
