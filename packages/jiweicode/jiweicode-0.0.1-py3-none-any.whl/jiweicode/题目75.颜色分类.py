# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，
           并按照红色、白色、蓝色顺序排列。

           注意:不能使用代码库中的排序函数来解决这道题。

           示例:
            输入: [2,0,2,1,1,0]
            输出: [0,0,1,1,2,2]

      分析：感觉这就是一个 遇到和  排位的问题。


      思路：
          对于这种遇到 与排位的问题，有两种直观的方法吧：
          【1】最为简单的，先进行一次遍历 来得到  对不同 数值的统计，为0的个数、1的个数、2的个数。
               再根据统计的次数进行数组的组织，这样其实也就一次O(N)的时间复杂度就搞定了。

               但是需要进行两次扫描数组， 第一次扫描是 记性计数的统计，第二次扫描是在数组本身上进行字符的改变。（本身修改，所以空间复杂度是不占据的，只是本身的O(N)）

          【2】第二种是 较为好的，时间复杂度较低的方式，相比于上一种方式，只进行一次的扫描，所以其效率是更高的，而且也是对本身进行修改的，完全可以。



         这里我还是喜欢自己常用的双指针法，方式较为简单灵活。

'''
class Solution(object):
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.

        这里  双指针方式，其实就类似是  快速排序中的方式，从前往后走【但是也跟快排中有很大不同】，我们需要的是      0在前面，2在后面，1在中间。

        所以可以按位置进行交换调整。  可以看到核心是设置了 lo、hi、i三个指针，分别表示 0位置、2位置、1位置，当我们由前往后走时，遇到三种情况：
           【1】遇到0，则跟 lo指标的进行交换
           【2】遇到1，则不管了，直接往后走 i+1
           【3】遇到2，则跟 hi的进行交换。

        核心就是以往的思考就可。
        """
        lo, hi = 0, len(nums) - 1
        i = 0
        while i <= hi:
            #对于遇到数的 三种方式的处理
            x = nums[i]
            if x == 0:
                nums[lo], nums[i] = nums[i], nums[lo]
                lo += 1
                i += 1
            elif x == 2:
                nums[hi], nums[i] = nums[i], nums[hi]
                hi -= 1
            else:
                i += 1


#___________________________________    练习1   ______________________________#
# 非常简单的一道题， 思路很明确，那么注重的其实就是  时间复杂度的问题，
#   这里 使用类似快速排序的思想（一次partation即可）    一次扫描下 不断进行交换调整即可
def fun1(nums):
    lo, hi = 0, len(nums) - 1
    i = 0

    # 从前往后探索吧
    while i <= hi:
        x = nums[i]
        # 如果是  0号颜色.   把数据转过去
        if x == 0:
            nums[lo], nums[i] = nums[i], nums[lo]
            lo += 1
            i += 1

        # 2号颜色，就按照索引往最右侧转移
        elif x == 2:
            nums[hi], nums[i] = nums[i], nums[hi]
            hi -= 1
        # 1号色 ，因为在中间，不做操作，正常放置即可
        else:
            i += 1
    return nums
