# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
    题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票）
    设计一个算法来计算你所能获取的最大利润。

    注意你不能在买入股票前卖出股票。

      示例 1:
        输入: [7,1,5,3,6,4]
        输出: 5
        解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
             注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
    分析：  非常经典简单的股票一次交易问题。 直接动态规划法，定义状态、状态转移搞定。

    思路：
'''
'''
    题意： 有一个股票，股票的价钱变化是[7,1,5,3,6,4],问你最多只能买卖k次时，最大的利润是多少，当前是6-1=5

    这个也是非常经典的动态规划问题，总共有三大因素需要考虑： 第几天、已经买卖了多少次、现在有没有持有股票
    （1）当然最简单的 思路就是  暴力求解，每一天都暴力比较买入和不买入的情况。
    （2）接下来是动态规划的思路，思考这里主要考虑的因素，我们可以将状态设定为三元素的组合。
         状态：定义为DP[i][k][j]，表示在第i天，已经进行k次交易时现有股票为j个时的最大利润。【主要i表示当前天上的状态情况】
         DP状态转移的推导：
             需要分别考虑当前时刻决策有  1个股票在手  和 没有股票的情况
             * 现有1个股票时DP[i,k,0]： Max(DP[i-1,k,0] 不进行新的买卖，不动, DP[i-1,k-1,1]+a[i] 当前卖了现在持有的股票，得到a[i]的效益)

             * 现有0个股票时DP[i,k,1]： Max(DP[i-1,k,1] 不进行买卖，不动，    DP[i-1,k-1,0]-a[i] 买入当前的股票，造成利润下降)

    对动态规划有一点感悟吧，感觉是可以画成一个树，是一种从前往后的结构，核心点就在于 状态的定义【主元素的思考】
                                                                            状态转移方程的定义【由前往后，主转移方程】
                在树的类推下不断求max,产生一种无影响下最大收益 总结获取的效果。
                
                
                
    思路还是挺清晰的，还是DP思想：
        记录【今天之前买入的最小值】
        计算 max【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】
        比较【每天的最大获利】，取最大值即可

'''
#################################    k值为1的限定情况   #########################
def gupiao_k1(prices):
    if not prices:
        return 0
    res=0
    # 定义状态
    dp=[[0 for _ in range(3)] for _ in range(len(prices))]
    #初始化状态， 维度为所有时间点， 定义每个时间点对应是三个元素，分别是没有买入股票时、买入一股还没卖、之前买了一股现在要卖掉
    dp[0][0],dp[0][1],dp[0][2]=0,-prices[0],0 #为负数是现在打算卖掉
    for i in range(1,len(prices)):
        #进行状态转移的推导
        dp[i][0] =dp[i-1][0]
        dp[i][1] =max(dp[i-1][1],dp[i-1][0]-prices[i])#可能是之前买的，或者上一次买的，取大的值
        dp[i][2] =dp[i-1][1]+prices[i]
        res=max(res,max(dp[i][0],dp[i][1],dp[i][2]))  #按照之前的理解，动态规划相当于构建了一个有记忆的树，则此处就是对树进行查找，最优收益的位置...一种无影响类推的效果。
    return res





#___________________________________    练习1    ______________________________#
def gupiao11(prices):
    prices=[2,3,4,63,23,53]

    if not prices:
        return 0

    res=0

    dp=[[0 for _ in range(3)] for _  in range(len(prices))]
    dp[0][0],dp[0][1],dp[0][2]=0,-prices[0],0  #初始化值

    for i in range(1,len(prices)):
        # 三种状态情况的更新
        dp[i][0]=dp[i-1][0] #无情况的迁移过来
        #这里的max要理解清楚，是思考本问题的核心，一种动态规划的本质，无前向性，只与后面的有关。(这里可以推断琢磨下，确实是这个道理，就是这样的max)
        dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])#之前买了一个股份， 或者现在买一个股份，看哪个效果好
        dp[i][2]=dp[i-1][1]+prices[i]  #正式卖掉的操作

        res=max(res,max(dp[i][0],dp[i][1],dp[i][2]))

    return res

