# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，
      请输入 0 来代替。

        例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

      分析：


      思路：

        线性扫描，开辟额外栈，每次扫描的新的元素 T[i] 时。
        （1）如果栈为空，就直接将元素下标 i 压到栈里，
        （2）如果栈不为空，而且栈顶 s[-1] 对应的气温 T[s[-1] ] 大于等于当前元素 T[i] ，说明气温没有回升，也把元素下标 i 压到栈里
        （3）如果栈顶 s[-1] 对应的气温 T[s[-1] ] 小于当前元素 T[i]，说明气温已经回升，那么对应的天数就是 i - s[-1]，重复上行和本行直到栈顶元素比当前元素大为止。

      分析:  上面的思路，时间复杂度为O(N)，空间复杂度也是O(N)，还是比较有意思的。以为在第三步时，会进行i - s[-1]的计算，就可以得到对应T中
      第s[-1]个索引所对应的数的  （需要再等待多久温度才会升高的天数），


'''
class Solution(object):
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        # 一个是 目标上升天数， 一个是临时栈
        res = [0] * len(T)
        s = []
        # print res
        for i in range(0, len(T)):
            #  情况 三 .因为已经回升了，那就回算索引对应位置值，并进行pop     注意这是个while，所以可以多次进行pop后的计算，一次不会有漏去
            while(s and T[i] > T[s[-1]]):
                # 这个是比较重要，其实就是获取到 栈顶对应下标，所代表的的数值的 目标意义值。
                res[s[-1]] = i - s[-1]
                s.pop()
            #  情况1和2的情况，这种 直接把索引压到栈即可。
            s.append(i)
        return res


#___________________________________    练习1   ______________________________#
#  这题思路比较简单，  就是找到每个 位置点，相隔多久就会有升温
#   题意是非常简单的，但是 这里不能僵硬化的做统计，而是  需要有高效的统计方式。   这里使用栈的方法 做统计

def fun1(T):
    #  状态的 初始化
    res=[0]*len(T)

    s=[]

    #  打印res
    for i in range(0,len(T)):
        #  核心的  情况三的处理
        while(s and T[i]>T[s[-1]]):
            # 获取  下标差，也就是需要的  第s[-1]位置应该对应的 目标递增差值。
            res[s[-1]]=i-s[-1]
            # 对计算好的弹出即可， 不断的pop非常有意思。
            s.pop()

        s.append(i)

    return res


