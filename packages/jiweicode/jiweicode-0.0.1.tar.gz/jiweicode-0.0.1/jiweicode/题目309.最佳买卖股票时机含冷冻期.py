# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
      设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
      你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
      卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

        示例:

        输入: [1,2,3,0,2]
        输出: 3 
        解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]


      分析：


      思路：  直接动态规划加一些 限制条件搞定。
      （可以思考的是，  动态规划就是一个有记忆体的 全遍历，所以所有的情况都是有所考虑，按照这个思维就行，后面的只使用前面的结论，而与之前发生的事件无关）

'''
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        dp = [[0 for _ in range(2)] for _ in range(len(prices))]
        for i, price in enumerate(prices):
            if i == 0:
                dp[0][0] = 0
                dp[0][1] = -price
            else:
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
                dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i]) #前天买的今天才能卖
        return dp[i][0] if prices else 0


#___________________________________    练习1   ______________________________#
#  好吧，这里就是在简单的 多次买卖一个股票买入卖出问题上， 添加了  冷冻期为一天的限制  【计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）】
                 #卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
#  输入的 prices表示当天的股价
def fun1(prices):
    # 设定初始状态矩阵，  每个状态表示 当天卖出收益 0 和当天买入收益 1
    dp=[[0 for _ in range(2)] for _ in range(len(prices))]

    # 进行较为复杂一些的 状态转移设置
    for i,price in enumerate(prices):
        # 第一天的情况 单独处理
        if i==0:
            dp[0][0]=0
            dp[0][1]=-price
        # 其他天的情况
        else:
            # 卖的情况，如常处理
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+price[i])
            # 进行购买时，就需要注意  有冷冻期的问题，之前卖出过一次，就不能立即买
            dp[i][1]=max(dp[i-1][1],dp[i-2][0]-price)

    # 看最后一天卖出后的收益情况，搞定
    return dp[len(prices)-1][0] if prices else 0
