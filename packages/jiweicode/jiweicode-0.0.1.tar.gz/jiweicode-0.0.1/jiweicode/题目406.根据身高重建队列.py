# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且
      身高大于或等于h的人数。 编写一个算法来重建这个队列。


          示例
            输入:
            [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

            输出:
            [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]

      题意就是根据 k的信息和 h身高数值 来找到  每个人作为合理的统计，应该所在的位置

      分析：  其实看这个意思，我们首先只需要题意明白，是原来是放置是无序的，但是第二个位置标明了  数值的该有放置大小地方关系。

            因此可以利用那种大小关系，分为 先排序再放置   和  不进行排序  的两种方法。
              比较简单的就是  练习1处的贪心方法吧，很有趣，有种突然 豁然开朗和思路精妙的感觉， 还有居然测试用例里有人身高是0 ，哈哈哈哈哈




      思路：  可以使用排序的方法解决问题

'''
class Solution:
    def reconstructQueue(self, people):
        people=sorted(people,key=lambda x:(-x[0],x[1]))
        res=[]
        for s in people:
            res.insert(s[1],s)
        return res

#___________________________________    练习1   ______________________________#
#  从两个角度进行书写吧，  一种是排序法（比较精妙有趣的思路；），另一种非排序法， 这里先使用排序法
def fun1(people):
    #  这里  sorted排序是双重要求，先优先按照 x[0]的降序，再按照x[1]的升序
    people = sorted(people, key=lambda x: (-x[0], x[1]))
    # print(people)            #[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]

    #  下面的效果，也是非常有意思，这里的 insert(插到的地方索引，插入的值)。  每次按照s[1]位置进行插入就能插对地方，之前插得会被挤在后面，
    #   然后那种    比大几个数的计数 不会影响，最后实现完整的过程，真的很巧妙，哇塞的解法，真有意思。
    res = []
    for s in people:
        res.insert(s[1], s)
    return res
fun1([[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]])


