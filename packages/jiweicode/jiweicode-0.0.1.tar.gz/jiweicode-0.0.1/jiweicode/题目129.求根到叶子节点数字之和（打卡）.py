
'''
      题目：给定一个二叉树，它的每个结点都存放一个?0-9?的数字，每条从根到叶子节点的路径都代表一个数字。
            例如，从根到叶子节点路径 1->2->3 代表数字 123。计算从根到叶子节点生成的所有数字之和。

            说明:?叶子节点是指没有子节点的节点。

                示例 1:

                输入: [1,2,3]
                    1
                   / \
                  2   3
                输出: 25
                解释:
                从根到叶子节点路径 1->2 代表数字 12.
                从根到叶子节点路径 1->3 代表数字 13.
                因此，数字总和 = 12 + 13 = 25.


      分析：

      思路：选用非递归的方式 进行求解，使用辅助栈的方式。

'''


#  可以有递归和非递归两种方式， 本次选用非递归的方式 进行求解，使用辅助栈的方式  (如下是使用先序遍历的方式，在遍历过程中 进行 数值的调整 和叶子的评估相加)
#  时间复杂度为O(N)，空间复杂度为O(log(N))
class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        stack = []
        p = root
        # 用于统计的总和
        sum = 0

        # 进行栈的利用上的 判别   左扩展压栈，右扩展出栈,先序遍历的方式
        while (p or stack):
            if p:
                # 首先压栈
                stack.append(p)
                # 进行当前位置下的 左遍历和  结点值更新
                if p.left:
                    p.left.val += p.val * 10
                p = p.left

            else:
                # 当p为空时，压栈来利用，同时肯定是左侧走过了，因此现在往右边走
                p = stack.pop()

                # 如果已经到了叶子地方
                if (not p.left and not p.right):
                    sum += p.val

                # 叶子的右结点进行扩展
                if p.right:
                    p.right.val += p.val * 10
                p = p.right

        return sum
