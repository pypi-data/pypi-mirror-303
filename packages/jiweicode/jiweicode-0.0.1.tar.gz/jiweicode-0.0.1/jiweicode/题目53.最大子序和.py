# coding: utf-8           使用学习生长法进行思考，  认真开始分析，  题不在多，在于精

'''
      题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

          示例:
            输入: [-2,1,-3,4,-1,2,1,-5,4],
            输出: 6
            解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

      分析：


      思路（动态规划法）：

           用dp[i]表示以下标为i的元素为结尾的最大子序和，

            当i = 0时，dp[0] = nums[0]

            当i = 1时，如果要跟前i-1个元素联系起来，就是dp[i-1] + nums[1]

                              如果不连起来，只考虑它自身，就是nums[1]

                              因为题目要求最大，所以dp[1] = max(dp[i-1] + nums[1], nums[1])
            ...

            以此类推，当dp[i-1]为正数的情况下，才有必要连起来，否则还不如nums[i]自己一个数字来的大
'''

class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int

        这是之前  被问过的一道题。

            这里的核心思想就在于语句：max(dp[i-1] + nums[i], nums[i])
            我们需要的最大的，也就是如果新加入的数 还不如不加，我们保存之前最大的即可，然后继续往后走。我们以res保存最终要保留的最大字序和。
            这里使用max的原因是 如果之前的加上当前的比 当前的还小， 那就保留当前的即可，否则就用 之前+当前标识  标识考虑当前情况下的最大 即可。

        """
        if not nums:
            return 0
        dp = [nums[0]]
        res = dp[0]
        for i in range(1, len(nums)):
            dp.append(max(dp[i-1] + nums[i], nums[i]))
            if dp[-1] > res:
                res = dp[-1]
        return res


#___________________________________    练习1   ______________________________#
# 最大子序列和的求取。    非常简单的动态规划法。（动态规划的精髓，后来发生的只与 之前的结论有关，而和之前的内容无关。）
# 注意这里是 连续的子序列，所以可以用单指针很好的进行控制，控制缩减过程。     而且是不限长度的，非常简单。
def fun1(nums):
    if nums:
        return 0
    #定义状态数组
    dp=[nums[0]]

    # 最大和统计    dp含义是过往的最大和
    res=dp[0]

    #进行状态转移操作
    for i in range(1,len(nums)):
        # 最为重要的 状态转移式        以 过去的最大和为判别
        dp.append(max(dp[i-1]+nums[i]),nums[i])
        if dp[-1]>res:
            res=dp[-1]
    return res

