{"version":3,"file":"file-url-D8DtV1l1.js","sources":["../../../wasm/dist/network/host.js","../../../wasm/dist/svelte/file-url.js"],"sourcesContent":["// A special hostname representing the Lite's server.\n// For example, when the endpoint is a local file (`file:/*`), the host name is set to this value (ref: determine_protocol() in client/js/src/helpers/init_helpers.ts)\nexport const FAKE_LITE_HOST = \"lite.local\";\nexport function is_self_host(url) {\n    return (url.host === window.location.host ||\n        url.host === \"localhost:7860\" ||\n        url.host === \"127.0.0.1:7860\" || // Ref: https://github.com/gradio-app/gradio/blob/v3.32.0/js/app/src/Index.svelte#L194\n        url.host === FAKE_LITE_HOST);\n}\n","import { getWorkerProxyContext } from \"./context\";\nimport { is_self_host } from \"../network/host\";\nimport { getHeaderValue } from \"../src/http\";\nexport function should_proxy_wasm_src(src) {\n    const is_browser = typeof window !== \"undefined\";\n    if (src == null || !is_browser) {\n        return false;\n    }\n    const url = new URL(src, window.location.href);\n    if (!is_self_host(url)) {\n        // `src` is not accessing a local server resource, so we don't need to proxy this request to the Wasm worker.\n        return false;\n    }\n    if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n        // `src` can be a data URL.\n        return false;\n    }\n    return true;\n}\nlet maybeWorkerProxy;\nexport async function resolve_wasm_src(src) {\n    const is_browser = typeof window !== \"undefined\";\n    if (src == null || !is_browser || !should_proxy_wasm_src(src)) {\n        return src;\n    }\n    if (maybeWorkerProxy == null) {\n        try {\n            maybeWorkerProxy = getWorkerProxyContext();\n        }\n        catch (e) {\n            // We are not in the Wasm env. Just use the src as is.\n            return src;\n        }\n    }\n    if (maybeWorkerProxy == null) {\n        // We are not in the Wasm env. Just use the src as is.\n        return src;\n    }\n    const url = new URL(src, window.location.href);\n    const path = url.pathname;\n    return maybeWorkerProxy\n        .httpRequest({\n        method: \"GET\",\n        path,\n        headers: {},\n        query_string: \"\"\n    })\n        .then((response) => {\n        if (response.status !== 200) {\n            throw new Error(`Failed to get file ${path} from the Wasm worker.`);\n        }\n        const blob = new Blob([response.body], {\n            type: getHeaderValue(response.headers, \"content-type\")\n        });\n        const blobUrl = URL.createObjectURL(blob);\n        return blobUrl;\n    });\n}\n"],"names":["FAKE_LITE_HOST","is_self_host","url","should_proxy_wasm_src","src","is_browser","maybeWorkerProxy","resolve_wasm_src","getWorkerProxyContext","path","response","blob","getHeaderValue"],"mappings":"sCAEO,MAAMA,EAAiB,aACvB,SAASC,EAAaC,EAAK,CAC9B,OAAQA,EAAI,OAAS,OAAO,SAAS,MACjCA,EAAI,OAAS,kBACbA,EAAI,OAAS,kBACbA,EAAI,OAASF,CACrB,CCLO,SAASG,EAAsBC,EAAK,CACvC,MAAMC,EAAa,OAAO,OAAW,IACrC,GAAID,GAAO,MAAQ,CAACC,EAChB,MAAO,GAEX,MAAMH,EAAM,IAAI,IAAIE,EAAK,OAAO,SAAS,IAAI,EAK7C,MAJI,GAACH,EAAaC,CAAG,GAIjBA,EAAI,WAAa,SAAWA,EAAI,WAAa,SAKrD,CACA,IAAII,EACG,eAAeC,EAAiBH,EAAK,CACxC,MAAMC,EAAa,OAAO,OAAW,IACrC,GAAID,GAAO,MAAQ,CAACC,GAAc,CAACF,EAAsBC,CAAG,EACxD,OAAOA,EAEX,GAAIE,GAAoB,KACpB,GAAI,CACAA,EAAmBE,EAAqB,CAC3C,MACS,CAEN,OAAOJ,CACV,CAEL,GAAIE,GAAoB,KAEpB,OAAOF,EAGX,MAAMK,EADM,IAAI,IAAIL,EAAK,OAAO,SAAS,IAAI,EAC5B,SACjB,OAAOE,EACF,YAAY,CACb,OAAQ,MACR,KAAAG,EACA,QAAS,CAAE,EACX,aAAc,EACtB,CAAK,EACI,KAAMC,GAAa,CACpB,GAAIA,EAAS,SAAW,IACpB,MAAM,IAAI,MAAM,sBAAsBD,CAAI,wBAAwB,EAEtE,MAAME,EAAO,IAAI,KAAK,CAACD,EAAS,IAAI,EAAG,CACnC,KAAME,EAAeF,EAAS,QAAS,cAAc,CACjE,CAAS,EAED,OADgB,IAAI,gBAAgBC,CAAI,CAEhD,CAAK,CACL"}