from .gen_common import TYPE_MAP
from .db_column import DbColumn
from .utils import snake_to_camel

RS_TEMPLATE = """
/**
 * This file was generated by the extract tool.
 * Do not modify this file manually.
 * Unless you know what you are doing or at your own risk
 */

use serde_json::{json, Value, to_value};

///
/// The struct of the %(table_entity)s
/// based on the database table %(resource_name)s
///
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct %(table_entity)s {
%(field_defs)s
}

///
/// The source-of-truth resource name (database table name) of the %(table_entity)s
///
pub const RESOURCE_NAME: &str = "%(resource_name)s";

///
/// The data column names of the %(table_entity)s
///
pub const FIELD_NAMES: [&str; %(field_count)s] = [%(field_names)s];

%(const_table_names)s

///
/// The data column set of the %(table_entity)s
///
pub fn field_name_set() -> std::collections::HashSet<String> {
    FIELD_NAMES.iter().map(|s| s.to_string()).collect()
}


///
/// Verify the input for the %(table_entity)s operation, make sure it's a valid payload
///
pub fn verify_common(input: &Value) -> anyhow::Result<()> {
    let name_set = field_name_set();
    if !input.is_object() {
        return Err(anyhow::anyhow!(
            "The input for the operation of %(table_entity)s must be a json object"
        ));
    }
    let input_map = input.as_object().unwrap();
    if input_map.keys().len() == 0 {
        return Err(anyhow::anyhow!(
            "The input for the operation of %(table_entity)s doesn't have any key"
        ));
    }
    let trespasser_option = input_map
        .keys()
        .find(|key| !name_set.contains(&key.to_string()));
    if let Some(trespasser) = trespasser_option {
        return Err(anyhow::anyhow!(
            "The input for the operation of %(table_entity)s has a key '{}' that is not allowed",
            trespasser
        ));
    }
    Ok(())
}

///
/// Verify the presence of required fields of the input for the %(table_entity)s operation
///
pub fn verify_required(input: &Value) -> anyhow::Result<()> {
    verify_common(input)?;
    let input_map = input.as_object().unwrap();
%(verify_required_list)s
    Ok(())
}

///
/// Get the default values for the %(table_entity)s's payload
///
pub fn get_defaults() -> Value {
%(default_val_declaration)s
    json!({
%(default_vals)s
    })
}

///
/// Get a combined payload with the given input, fill the missing fields with default values
///
pub fn defaults_if_absent(input: &Value) -> anyhow::Result<Value> {
    verify_common(input)?;
    let input_map = input.as_object().unwrap();
    let defaults = get_defaults();
    let ret = defaults.as_object().unwrap().iter().chain(input_map)
        .map(|item| (item.0.to_string(), item.1.clone()))
        .collect::<std::collections::HashMap<String, Value>>();
    Ok(to_value(ret)?)
}
"""


def get_rs_code(resource_name: str, column_defs: list[DbColumn]) -> str:
    """
    Generate Rust code for a database table schema

    :param resource_name: The name of the database table
    :param column_defs: The list of column definitions
    """
    field_defs = []
    field_names = []
    default_vals = []
    const_table_names = []
    verify_required_list = []
    default_val_declaration = []
    default_vals = []
    for col in column_defs:
        table_entity = snake_to_camel(resource_name, True)
        const_table_names.append(
            f'pub const COL_NAME_{col.name.upper()}: &str = "{col.name}";'
        )
        normal_field_type = TYPE_MAP[col.field_type]["rs"]
        field_type = (
            normal_field_type if col.not_null else "Option<%s>" % normal_field_type
        )
        field_defs.append(f"\t{col.name}: {field_type}")
        field_names.append(f'"{col.name}"')
        if col.not_null:
            verify_required_list.append(
                f'\tif input_map.get("{col.name}").is_none() {{ return Err(anyhow::anyhow!("The input for the operation of {table_entity} requires the value of \'{col.name}\'"));}}'
            )
        if col.default_val:
            default_val_display = (
                f'r#"{col.default_val}"#'
                if col.field_type == "TEXT"
                else col.default_val
            )
            default_val_declaration.append(
                f"\tlet val_{col.name} = {default_val_display};"
            )
            default_vals.append(f'\t"{col.name}": val_{col.name},')
    return RS_TEMPLATE % {
        "table_entity": table_entity,
        "field_defs": ",\n".join(field_defs),
        "field_names": ", ".join(field_names),
        "field_count": len(field_names),
        "resource_name": resource_name,
        "const_table_names": "\n".join(const_table_names),
        "verify_required_list": "\n".join(verify_required_list),
        "default_vals": "\n".join(default_vals),
        "default_val_declaration": "\n".join(default_val_declaration),
    }
