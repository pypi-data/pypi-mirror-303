import json
from .utils import snake_to_camel
from .db_column import DbColumn
from .gen_common import TYPE_MAP


TS_TEMPLATE = """
/**
 * This file was generated by the extract tool.
 * Do not modify this file manually.
 * Unless you know what you are doing or at your own risk
 */

/**
 * The type of string constrained to the field names of the %(table_entity)s
 */
export type FieldName = %(field_type_list)s;

export type Payload = Record<FieldName, any>;

/**
 * The entity type of the %(table_entity)s
 */
export interface %(table_entity)s {
%(field_defs)s
}

/**
 * The data-column names list of the %(table_entity)s
 */
export const FIELD_NAMES: readonly FieldName[] = Object.freeze([%(field_names)s]);

/**
 * The source-of-truth resource name resource name (database table name) of the %(table_entity)s
 */
export const RESOURCE_NAME = '%(resource_name)s';

%(const_table_names)s

/**
 * The data-column name set of the %(table_entity)s
 */
export const FieldNameSet: ReadonlySet<FieldName> = Object.freeze(new Set(FIELD_NAMES));

/**
 * Verify the input for the %(table_entity)s operation, make sure it's a valid payload
 */
export function verify_common(input: Payload): void {
    if (Object.keys(input).length == 0) {
        throw new Error(`The input for the operation of %(table_entity)s doesn't have any key`);
    }
    const trespasser_option = Object.keys(input).find(key => !(FieldNameSet as Set<string>).has(key));
    if (trespasser_option) {
        throw new Error(`The input for the operation of %(table_entity)s has a key '${trespasser_option}' that is not allowed`);
    }
}

/**
 * Verify the presence of required fields of the input for the %(table_entity)s operation
 */
export function verify_required(input: Payload): void {
    verify_common(input);
%(verify_required_list)s
}

/**
 * Get the default values for the %(table_entity)s's payload
 */
export function get_defaults(): Payload {
    const ret = {} as Payload;
%(default_vals)s
    return ret;
}

/**
 * Get a combined payload with the given input, fill the missing fields with default values
 */
export function defaults_if_absent(input: Payload): Payload {
    verify_common(input);
    return {
        ...get_defaults(),
        ...input,
    };
}
"""


def get_ts_code(resource_name: str, column_defs: list[DbColumn]) -> str:
    """
    Generate TypeScript code for a database table schema

    :param resource_name: The name of the database table
    :param column_defs: The list of column definitions
    """
    field_defs = []
    field_names = []
    const_table_names = []
    verify_required_list = []
    default_vals = []
    for col in column_defs:
        required = "" if col.not_null else "?"
        field_defs.append(f"\t{col.name}{required}: {TYPE_MAP[col.field_type]['ts']};")
        field_names.append(f"'{col.name}'")
        const_table_names.append(
            f'export const COL_NAME_{col.name.upper()} = "{col.name}";'
        )
        if col.not_null:
            error_code = f"""throw new Error(`The input for the operation of %(table_entity)s requires value for the key '${col.name}'`);"""
            verify_required_list.append(
                f"\t\tif (input.{col.name} == null) {{ {error_code} }};"
                % {"table_entity": snake_to_camel(resource_name, True)}
            )
        if col.default_val is not None:
            display_val = (
                col.default_val
                if col.field_type != "TEXT"
                else f"{json.dumps(col.default_val)}"
            )
            default_vals.append(f"\tret.{col.name} = {display_val};")

    return TS_TEMPLATE % {
        "table_entity": snake_to_camel(resource_name, True),
        "field_defs": "\n".join(field_defs),
        "field_names": ", ".join(field_names),
        "field_type_list": " | ".join(field_names),
        "resource_name": resource_name,
        "const_table_names": "\n".join(const_table_names),
        "verify_required_list": "\n".join(verify_required_list),
        "default_vals": "\n".join(default_vals),
    }
