from abc import ABC, abstractmethod
from typing import Any, Callable, Dict, List, Set, Tuple, Union


class Path:
    '''
    Container for a path.
    '''
    def __init__(self, jq_path: str, item: Any, line_num: int = -1):
        '''
        :param jq_path: A fully-qualified indexed path.
        :param item: The path's item (value)
        '''
        self.jq_path = jq_path
        self.item = item
        self.line_num = line_num
        self._path_elts = None  # jq_path.split('.')
        self._len = None  # Number of path elements

    def __repr__(self) -> str:
        lnstr = f'{self.line_num}: ' if self.line_num >= 0 else ''
        return f'{lnstr}{self.jq_path}: {self.item}'

    def __key(self):
        return (self.jq_path, self.item) if self.line_num < 0 else self.line_num

    def __lt__(self, other: 'Path') -> bool:
        if self.line_num < 0 or other.line_num < 0:
            return self.jq_path < other.jq_path
        else:
            return self.line_num < other.line_num

    def __hash__(self) -> int:
        return hash(self.__key())

    def __eq__(self, other):
        if isinstance(other, Path):
            return self.__key() == other.__key()
        return NotImplemented

    @property
    def path_elts(self) -> List[str]:
        ''' Get this path's (index-qualified) elements '''
        if self._path_elts is None:
            self._path_elts = self.jq_path.split('.')
        return self._path_elts

    @property
    def size(self) -> int:
        ''' Get the number of path_elements in this path. '''
        return len(self.path_elts)


class GroupAcceptStrategy(ABC):
    '''
    Add a Path to a Group if it belongs.
    '''
    @abstractmethod
    def accept_path(
            self,
            path: Path,
            group: 'PathGroup',
            distribute: bool = False
    ) -> str:
        '''
        Determine whether the Path belongs in the group.
        :param path: The path to potentially add
        :param group: The group to which to add the path
        :param distribute: True if the path is proposed as a distributed path
            instead of as a main path.
        :return: 'main', 'distributed', or None if the path belongs as a main
            path, a distributed path, or not at all in the group
        '''
        raise NotImplementedError


class PathGroup:
    '''
    Container for a group of related paths.
    '''
    def __init__(
            self,
            accept_strategy: GroupAcceptStrategy,
            first_path: Path = None
    ):
        self.accept_strategy = accept_strategy
        self.main_paths = {first_path} if first_path is not None else None
        self.distributed_paths = None  # Set[Path]
        self._all_paths = None

    @property
    def num_main_paths(self) -> int:
        ''' Get the number of main paths in this group '''
        return len(self.main_paths) if self.main_paths is not None else 0

    @property
    def num_distributed_paths(self) -> int:
        ''' Get the number of distributed paths in this group '''
        return (
            len(self.distributed_paths)
            if self.distributed_paths is not None
            else 0
        )

    @property
    def size(self) -> int:
        ''' Get the total number of paths in this group. '''
        return self.num_main_paths + self.num_distributed_paths

    @property
    def paths(self) -> List[Path]:
        ''' Get all paths (both main and distributed) '''
        if self._all_paths is None:
            if self.main_paths is not None:
                self._all_paths = self.main_paths.copy()
                if self.distributed_paths is not None:
                    self._all_paths.update(self.distributed_paths)
                self._all_paths = sorted(self._all_paths)
            elif self.distributed_paths is not None:
                self._all_paths = sorted(self.distributed_paths)
        return self._all_paths

    def as_dict(self) -> Dict[str, str]:
        ''' Reconstruct the object from the paths '''
        d = dict()
        if self.paths is not None:
            for path in self.paths:
                jutils.path_to_dict(path.jq_path, path.item, result=d)
        return d

    def accept(self, path: Path, distribute: bool = False) -> bool:
        '''
        Add the path if it belongs in this group.
        :param path: The path to (potentially) add.
        :param distribute: True to propose the path as a distributed path
        :return: True if the path was accepted and added.
        '''
        added = False
        add_type = self.accept_strategy.accept_path(path, self, distribute=False)
        if add_type is not None:
            if add_type == 'main':
                if self.main_paths is None:
                    self.main_paths = {path}
                else:
                    self.main_paths.add(path)
            else:  # 'distributed'
                if self.distributed_paths is None:
                    self.distributed_paths = {path}
                else:
                    self.distributed_paths.add(path)
            added = True
            self._all_paths = None
        return added

    def incorporate_paths(self, group: 'PathGroup'):
        '''
        Incorporate (distribute) the group's appliccable paths into this group.
        '''
        for path in group.paths:
            self.accept(path, distribute=True)


class SeededGroupAcceptStrategy(GroupAcceptStrategy):
    '''
    Strategy for accepting paths into a group of paths built around a "seed"
    path.
    '''
    def __init__(self):
        self._longest_path = None

    def accept_path(
            self,
            path: Path,
            group: PathGroup,
            distribute: bool = False
    ):
        if not distribute:
            self._update_longest_path(path, group)
        if group.num_main_paths == 0 or self._path_aligns(path, group):
            return 'distributed' if distribute else 'main'
        return None

    def _update_longest_path(self, path: Path, group: PathGroup):
        if self._longest_path is None:
            if group.num_main_paths > 0:
                self._longest_path = group.main_paths[0]
                for path in group.main_paths[1:]:
                    if path.size > self._longest_path.size:
                        self._longest_path = path
            else:
                self._longest_path = path
        else:
            if path.size > self._longest_path.size:
                self._longest_path = path

    def _path_aligns(self, path: Path, group: PathGroup) -> bool:
        '''
        Determine whether the path aligns with the group's paths.
        '''
        if path.size > self._longest_path.size:
            lpath = path
            opath = self._longest_path
        else:
            lpath = self._longest_path
            opath = path
        return self._paths_align(lpath, opath)

    @staticmethod
    def _paths_align(longer_path: Path, other_path: Path) -> bool:
        '''
        Determine whether the other path aligns with the longer path.
        '''
        aligns = True
        for idx in range(1, min(other_path.size, longer_path.size - 1)):
            # start at 1 because path_elt[0] is always ''
            # end at longer_path.size - 1 if paths are equal to keep terminal
            #     arrays in the same record
            lelt = longer_path.path_elts[idx]
            oelt = other_path.path_elts[idx]
            if lelt != oelt:
                # Doesn't align if matches up to [] (because idx differs)
                if (lelt[-1] == ']' and oelt[-1] == ']'):
                    # At an array level
                    if (
                            idx == 1 or  # always force a change at top level
                            lelt[:lelt.find('[')] == oelt[:oelt.find('[')]
                    ):
                        aligns = False
                        break
        return aligns


class ArrayElementAcceptStrategy(GroupAcceptStrategy):
    '''
    Container for a consistent group of paths built around each array.
    '''
    def __init__(self, max_array_level: int = -1):
        self.max_array_level = max_array_level
        self.ref_path = None

    def accept_path(
            self,
            path: Path,
            group: PathGroup,
            distribute: bool = False
    ):
        if distribute or not '[' in path.jq_path:
            return 'distributed'

        if group.main_paths is None:
            # Accept first path with an array
            self.ref_path = path
            return 'main'
        else:
            # All elements up through max_array_level must fully match
            cur_array_level = -1
            for idx in range(1, min(self.ref_path.size, path.size)):
                ref_elt = self.ref_path.path_elts[idx]
                path_elt = path.path_elts[idx]
                if ref_elt != path_elt:
                    return None
                elif ref_elt[-1] == ']':
                    cur_array_level += 1
                    if cur_array_level >= self.max_array_level:
                        break
        return 'main'
